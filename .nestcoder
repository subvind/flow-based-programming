# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/flow-based-programming/src/schema/flow.schema.ts">
import { Flow } from "../interfaces/flow.interface";

export function schema(flow: any): Flow {
  const components = Object.entries(flow.components).map(([componentId, component]) => {
    const [componentRef] = Object.keys(component);
    let init;
    if (componentRef === 'stateMachine' && component[componentRef].init) {
      init = component[componentRef].init;
    }
    return { componentId, componentRef, init };
  });

  const connections = flow.connections.map((connection) => {
    const fromParts = connection.from.split('.');
    const toParts = connection.to.split('.');

    // 0          1    2            3      4
    // components.main.eventTrigger.events.initializeMachine
    
    return {
      fromFlow: flow.id,
      fromComponent: fromParts[1],
      fromEvent: fromParts[4],
      toFlow: flow.id,
      toComponent: toParts[1],
      toEvent: toParts[4],
    };
  });

  let code = {
    id: flow.id,
    components,
    connections,
  };

  // console.log('code', code);

  return code;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/stateMachines/job.state-machine.ts">
export default {
  initialState: 'idle',
  states: ['idle', 'running', 'paused', 'finished'],
  transitions: {
    idle: { start: 'running' },
    running: { pause: 'paused', finish: 'finished' },
    paused: { resume: 'running', finish: 'finished' },
    finished: { reset: 'idle' }
  }
}

</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/component.interface.ts">
import { Connection } from "./connection.interface";
import { Port } from "./port.interface";

export interface Component {
  ports: { inputs: string[]; outputs: string[]; };
  componentRef: string;
  slug: string;
  description?: string;
  flowId: string;
  componentId: string;
  handleEvent: (eventId: string, data: any) => Promise<void>;
  publish: (flowId: string, componentId: string, eventId: string, data: any) => Promise<void>;
  getPorts: () => Promise<{ inputs: Port[], outputs: Port[] }>;
  findPort: (portId: string) => Promise<Port>;
  findConnections: (port: Port) => Promise<Connection[]>
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/connection.interface.ts">
import { Component } from "./component.interface";

export interface Connection {
  toFlow: string;
  toComponent: string;
  toEvent: string;
  connectedTo: Component | undefined;
  fromFlow: string;
  fromComponent: string;
  fromEvent: string;
  connectedFrom: Component | undefined;
  next: Component | undefined;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/flow.interface.ts">
import { Connection } from "./connection.interface";

export interface Flow {
  id: string;
  components: {
    componentId: string;
    componentRef: string;
    init: any | undefined;
  }[];
  connections: Connection[];
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/port.interface.ts">
import { Connection } from "./connection.interface";

// portId format: <dataType>.<dataMethod>.<eventId>
export interface Port {
  direction: 'input' | 'output'
  dataType: string;
  dataMethod: 'display' | 'publish';
  eventId: string;
  connections: Connection[];
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/state-machine.interface.ts">
import { Component } from "./component.interface";

export interface StateMachine extends Component {
  initializeMachine: (data: any) => Promise<void>;
  getCurrentState: () => string;
  getStates: () => Set<string>;
  getTransitions: () => Map<string, Map<string, string>>;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/button-trigger/button-trigger.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';

import { triggerButton } from './trigger-button.event';

@Injectable()
export class ButtonTriggerComponent extends ComponentBase {
  public logger: CustomLogger;
  public ports = {
    inputs: [
      'any.publish.triggerButton',
    ],
    outputs: [
      'any.publish.buttonPressed',
      'htmx.display.button-trigger'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server
  ) {
    super('buttonTrigger', 'button-trigger', 'Handles button presses and triggers events', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "triggerButton": {
        await this.triggerButton(data);
        break;
      }
      default: {
        break;
      }
    }
  }

  private async triggerButton(data: any): Promise<void> {
    return triggerButton(this, data);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/event-trigger/event-trigger.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';

import { triggerEvent } from './trigger-event.event';

@Injectable()
export class EventTriggerComponent extends ComponentBase {
  public logger;
  public ports = { // io format: <dataType>.<dataMethod>.<eventId>
    inputs: [
      'any.publish.triggerEvent',
    ],
    outputs: [
      'any.publish.any'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server
  ) {
    super('eventTrigger', 'event-trigger', 'Handles HTMX requests and triggers events', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    switch (eventId) {
      case 'triggerEvent':
        await this.triggerEvent(data);
        break;
      default:
        break;
    }
  }

  private async triggerEvent(data): Promise<void> {
    return await triggerEvent(this, data);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/job-state-machine/job-state-machine.handler.ts">
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';
import { CustomLogger } from '../../logger/custom-logger';

import { StateMachineComponent } from '../state-machine/state-machine.handler';

@Injectable()
export class JobStateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  private stateMachine: StateMachineComponent;
  
  public ports = {
    inputs: [
      'any.publish.initializeMachine',
      'any.publish.start',
      'any.publish.pause',
      'any.publish.resume',
      'any.publish.finish',
      'any.publish.reset'
    ],
    outputs: [
      'any.publish.initializeMachine',
      'any.publish.start',
      'any.publish.pause',
      'any.publish.resume',
      'any.publish.finish',
      'any.publish.reset',
      'any.publish.stateChanged',
      'htmx.display.job-state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
  ) {
    super('jobStateMachine', 'job-state-machine', 'Implements a job state machine', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "initializeMachine": {
        await this.initializeMachine(data);
        break;
      }
      case "start":
      case "pause":
      case "resume":
      case "finish":
      case "reset": {
        await this.transition(eventId);
        break;
      }
    }
  }

  private async initializeMachine(data: any): Promise<void> {
    this.getPorts();
    this._ports.inputs.forEach((input) => {
      input.connections.forEach(async (connection) => {
        let smComponent: any = connection.connectedFrom;

        await smComponent.initializeMachine(data);
        await this.updateDisplay(smComponent);

        let currentState = await smComponent.getCurrentState()
        await this.publish(this.flowId, this.componentId, 'initializeMachine', { 
          currentState
        });
      })
    })
  }

  private async transition(event: string): Promise<void> {
    let previousState;
    let currentState;
    this.getPorts();
    this._ports.inputs.forEach((input) => {
      input.connections.forEach(async (connection) => {
        let smComponent: any = connection.connectedFrom;
        previousState = await smComponent.getCurrentState();
        await this.stateMachine.transition({ event });
        currentState = await smComponent.getCurrentState();

        await this.updateDisplay(smComponent);
      })
    });
    

    // Publish to the specific event port
    await this.publish(this.flowId, this.componentId, event, { 
      previousState,
      currentState
    });

    // Also publish to the general stateChanged port
    await this.publish(this.flowId, this.componentId, 'stateChanged', { 
      previousState,
      currentState,
      event
    });
  }

  private async updateDisplay(stateMachineComponent): Promise<void> {
    let currentState = await stateMachineComponent.getCurrentState();
    let states = await stateMachineComponent.getStates();
    let transitions = await stateMachineComponent.getTransitions();

    await this.display(this.flowId, this.componentId, 'job-state-machine', {
      currentState,
      states: Array.from(states),
      transitions: Object.fromEntries(transitions)
    });
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/number-generator/number-generator.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';

import { startGenerating } from './start-generating.event';
import { stopGenerating } from './stop-generating.event';

@Injectable()
export class NumberGeneratorComponent extends ComponentBase {
  public logger;
  public interval: NodeJS.Timeout | null = null;
  public ports = { // io format: <dataType>.<dataMethod>.<eventId>
    inputs: [
      'any.publish.start',
      'any.publish.stop'
    ],
    outputs: [
      'number.publish.numberGenerated',
      'htmx.display.number-generator'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server
  ) {
    super('numberGenerator', 'number-generator', 'Generates random numbers periodically', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`NumberGenerator (${this.flowId}) handling event: ${eventId}`);
    switch (eventId) {
      case "start": {
        this.logger.log(`NumberGenerator (${this.flowId}) starting number generation`);
        this.startGenerating(data);
        break;
      }
      case "stop": {
        this.logger.log(`NumberGenerator (${this.flowId}) stopping number generation`);
        this.stopGenerating(data);
        break;
      }
    }
  }

  private startGenerating(data): void {
    return startGenerating(this, data);
  }

  private stopGenerating(data): void {
    return stopGenerating(this, data);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/number-multiplier/number-multiplier.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';

import { numberReceived } from './number-received.event';

@Injectable()
export class NumberMultiplierComponent extends ComponentBase {
  public logger;
  public ports = { // io format: <dataType>.<dataMethod>.<eventId>
    inputs: [
      'number.publish.firstNumberReceived',
      'number.publish.secondNumberReceived',
    ],
    outputs: [
      'number.publish.numberMultiplied',
      'htmx.display.number-multiplier',
    ]
  }

  public firstNumber: number | null = null;
  public secondNumber: number | null = null;

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server
  ) {
    super('numberMultiplier', 'number-multiplier', 'Multiplies two received numbers', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`NumberMultiplier handling event: ${eventId} ${JSON.stringify(data, null, 2)}`);
    switch (eventId) {
      case 'firstNumberReceived':
        await this.numberReceived(data, 'first');
        break;
      case 'secondNumberReceived':
        await this.numberReceived(data, 'second');
        break;
      default:
        break;
    }
  }

  private numberReceived(data: any, which: 'first' | 'second'): Promise<void> {
    return numberReceived(this, data, which);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/state-machine/state-machine.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';

import { init } from './init.event';
import { initializeMachine } from './initialize-machine.event';
import { transition } from './transition.event';

@Injectable()
export class StateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  public currentState: string;
  public states: Set<string>;
  public transitions: Map<string, Map<string, string>>;
  
  public ports = {
    inputs: [
      'any.publish.initializeMachine',
      'any.publish.transition'
    ],
    outputs: [
      'any.publish.stateChanged',
      'htmx.display.state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server
  ) {
    super('stateMachine', 'state-machine', 'Implements a simple state machine', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
    this.states = new Set();
    this.transitions = new Map();
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "init": {
        await this.init(data);
        break;
      }
      case "initializeMachine": {
        await this.initializeMachine(data);
        break;
      }
      case "transition": {
        await this.transition(data);
        break;
      }
      default: {
        this.logger.warn(`Unknown event: ${eventId}`);
      }
    }
  }

  public async init(data: any): Promise<void> {
    return init(this, data);
  }

  public async initializeMachine(data: any): Promise<void> {
    return initializeMachine(this, data);
  }

  public async transition(data: any): Promise<void> {
    return transition(this, data);
  }

  public getCurrentState(): string {
    return this.currentState;
  }

  public getStates(): Set<string> {
    return this.states;
  }

  public getTransitions(): Map<string, Map<string, string>> {
    return this.transitions;
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/bases/component.base.ts">
import { Inject, Injectable } from '@nestjs/common';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Component } from '../interfaces/component.interface';
import { CustomLogger } from '../logger/custom-logger';
import { WebSocketGateway, WebSocketServer, SubscribeMessage, MessageBody } from '@nestjs/websockets';
import { Server } from 'socket.io';
import * as ejs from 'ejs';
import * as path from 'path';
import { Connection } from 'src/interfaces/connection.interface';
import { Port } from 'src/interfaces/port.interface';
import { ComponentRegistry } from 'src/services/component-registry.service';

@WebSocketGateway()
@Injectable()
export abstract class ComponentBase implements Component {
  protected readonly logger: CustomLogger;
  public _ports: { inputs: Port[]; outputs: Port[]; };
  public ports: { inputs: string[]; outputs: string[]; };
  public _connections: Map<string, Component> = new Map();
  public connections: Connection[];

  constructor(
    public componentId: string,
    public slug: string,
    public description: string,
    public flowId: string,
    public componentRef: string,
    @Inject(AmqpConnection) protected amqpConnection: AmqpConnection,
    protected server: Server,
  ) {
    this.logger = new CustomLogger(this.componentId, amqpConnection);
  }

  abstract handleEvent(eventId: string, data: any): Promise<void>;

  async publish(flowId: string, componentId: string, eventId: string, data: any): Promise<void> {
    this.logger.log(`Publishing: ${flowId}.${componentId}.${eventId} -> ${data}`);
    if (!this.amqpConnection) {
      this.logger.error('AmqpConnection is not initialized');
      return;
    }
    await this.amqpConnection.publish('flow_exchange', 'componentEvent', {
      flowId,
      componentId,
      eventId,
      data,
    });
  }

  @SubscribeMessage('client-event')
  handleClientEvent(@MessageBody() data: any): void {
    const { flowId, componentId, eventId, ...eventData } = data;
    this.logger.log(`Received client event: flowId=${flowId}, componentId=${componentId}, eventId=${eventId}, data=${JSON.stringify(eventData)}`);
    this.publish(flowId, componentId, 'clientEventReceived', eventData);
  }

  public async display(flowId: string, componentId: string, templateId: string, data: any) {
    data._flowId = flowId;
    data._componentId = componentId;
    data._templateId = templateId;
    const htmxContent = await this.generateHtmxContent(data);
    
    if (this.server) {
      this.logger.log(htmxContent)
      this.server.emit('display-flow-component-template-content', {
        flowId,
        componentId,
        templateId,
        content: htmxContent
      });
    } else {
      this.logger.warn('WebSocket server is not initialized');
    }
  }

  private async generateHtmxContent(data: any): Promise<string> {
    const templatePath = path.resolve(__dirname, `../templates/${data._templateId}.ejs`);
    try {
      return await ejs.renderFile(templatePath, data);
    } catch (error) {
      this.logger.error(`Error rendering EJS template: ${error.message}`);
      return `<div>Error rendering content</div>`;
    }
  }

  public syncConnections(connections: Connection[], componentRegistry: ComponentRegistry): void {
    if (connections) {
      this.connections = [];
      connections.forEach((connection, index) => {
        // console.log('connection', connection);
        // console.log('this.componentRegistry', componentRegistry)
        if (connection.fromFlow === this.flowId && connection.fromComponent === this.componentId) {
          // console.log(`from is the current instance so register to instance`);
          const connectionKey = `${connection.fromEvent}>${connection.toFlow}.${connection.toComponent}.${connection.toEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.toFlow, connection.toComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = connectedComponentInstance;
          connection.connectedFrom = this;
          this.connections.push(connection);
        } else if (connection.toFlow === this.flowId && connection.toComponent === this.componentId) {
          // console.log(`to is the current instance so register from instance`);
          const connectionKey = `${connection.toEvent}>${connection.fromFlow}.${connection.fromComponent}.${connection.fromEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.fromFlow, connection.fromComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = this;
          connection.connectedFrom = connectedComponentInstance;
          this.connections.push(connection);
        } else {
          // connection does not match; do nothing.
        }
      })
    }
  }

  // TODO: addPort()

  // TODO: removePort()

  // TODO: connectComponentToPort()

  // TODO: disconnectComponentFromPort()

  public async getPorts(): Promise<{ inputs: Port[], outputs: Port[] }> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    let ports = {
      inputs: [],
      outputs: []
    }
    this.ports.inputs.forEach(async (input) => {
      let i = input.split('.');
      let port: Port = {
        direction: 'input',
        dataType: i[0],
        dataMethod: i[1] === 'display' ? 'display' : 'publish',
        eventId: i[2],
        connections: [...await this.loadConnections('input', i[2])]
      }
      ports.inputs.push(port);
    });
    this.ports.outputs.forEach(async (output) => {
      let o = output.split('.');
      let port: Port = {
        direction: 'output',
        dataType: o[0],
        dataMethod: o[1] === 'display' ? 'display' : 'publish',
        eventId: o[2],
        connections: [...await this.loadConnections('output', o[2])]
      }
      ports.outputs.push(port);
    });
    this._ports = ports;
    return ports;
  }

  private async loadConnections(direction: string, eventId: string): Promise<Connection[]> {
    let connections: Connection[] = [];
    // console.log('this.connections', this.connections);
    if (this.connections) {
      this.connections.forEach((connection: Connection) => {
        // console.log('connection', connection);
        if (direction === 'input') {
          if (connection.toEvent === eventId) {
            connections.push(connection);
          }
        } else {
          if (connection.fromEvent === eventId) {
            connections.push(connection);
          }
        }
      });
      return connections;
    } else {
      return [];
    }
  }

  public async findPort(portId: string): Promise<Port> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    const pId = portId.split('.');
    const eventId = pId[2];
    const ports = await this.getPorts();
    let port: Port;
    ports.inputs.forEach((input: Port) => {
      if (input.eventId === eventId) {
        port = input;
      }
    });
    ports.outputs.forEach((output: Port) => {
      if (output.eventId === eventId) {
        port = output;
      }
    });
    return port;
  }

  public async findConnections(port: Port): Promise<Connection[]> {
    if (port && port.connections) {
      return port.connections;
    }
    return [];
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/bases/flow.base.ts">
import { Connection } from 'src/interfaces/connection.interface';
import { Flow } from '../interfaces/flow.interface';

export class FlowBase implements Flow {
  public connections: Connection[] = [];
  constructor(
    public id: string,
    public components: any,
    public _connections: {
      fromComponent: string;
      fromEvent: string;
      toComponent: string;
      toEvent: string;
    }[]
  ) {
    this.id = id;
    this.components = components;
    this._connections = _connections;
    this.setupConnections();
  }

  private async setupConnections(): Promise<Connection[]> {
    this._connections.forEach((connection) => {
      let c: Connection = {
        ...connection,
        toFlow: this.id,
        fromFlow: this.id,
        connectedTo: undefined, // TODO
        connectedFrom: undefined, // TODO
        next: undefined // TODO
      }
      this.connections.push(c);
    })
    return this.connections;
  }
};
</FILE>
<FILE path="src/flows/example-flow.flow.ts" TARGET>
import { schema } from "../schema/flow.schema"; 
import { default as jobStateMachine } from "src/stateMachines/job.state-machine";

let numberGenerator = {
  ports: {
    inputs: {
      start: {},
      stop: {}
    },
    outputs: {
      numberGenerated: {}
    }
  }
}

let buttonTrigger = {
  ports: {
    inputs: {
      triggerButton: {}
    },
    outputs: {
      buttonPressed: {}
    }
  }
}

let components = {
  main: {
    eventTrigger: {
      ports: {
        inputs: {},
        outputs: {}
      }
    }
  },
  btn1: { buttonTrigger },
  btn2: { buttonTrigger },
  btn3: { buttonTrigger },
  btn4: { buttonTrigger },
  btn5: { buttonTrigger },
  sm1: {
    stateMachine: {
      init: jobStateMachine,
      ports: {
        inputs: {
          initializeMachine: {}
        },
        outputs: {}
      }
    }
  },
  jsm1: {
    jobStateMachine: {
      ports: {
        inputs: {
          initializeMachine: {},
          start: {},
          pause: {},
          resume: {},
          finish: {},
          reset: {}
        },
        outputs: {
          stateChanged: {}
        }
      }
    }
  },
  gen1: {
    numberGenerator
  },
  gen2: {
    numberGenerator
  },
  multi: {
    numberMultiplier: {
      ports: {
        inputs: {
          firstNumberReceived: {},
          secondNumberReceived: {}
        },
        outputs: {
          numberMultiplied: {}
        }
      }
    }
  }
}

let flow = {
  id: 'example-flow',
  components,
  connections: [
    {
      from: 'components.sm1.stateMachine.ports.outputs.initializeMachine',
      to: 'components.jsm1.jobStateMachine.ports.inputs.initializeMachine'
    },
    {
      from: 'components.jsm1.jobStateMachine.ports.outputs.stateChanged',
      to: 'components.gen1.numberGenerator.ports.inputs.start'
    },
    {
      from: 'components.jsm1.jobStateMachine.ports.outputs.stateChanged',
      to: 'components.gen1.numberGenerator.ports.inputs.stop'
    },
    {
      from: 'components.jsm1.jobStateMachine.ports.outputs.stateChanged',
      to: 'components.gen2.numberGenerator.ports.inputs.start'
    },
    {
      from: 'components.jsm1.jobStateMachine.ports.outputs.stateChanged',
      to: 'components.gen2.numberGenerator.ports.inputs.stop'
    },
    {
      from: 'components.gen1.numberGenerator.ports.outputs.numberGenerated',
      to: 'components.multi.numberMultiplier.ports.inputs.firstNumberReceived'
    },
    {
      from: 'components.gen2.numberGenerator.ports.outputs.numberGenerated',
      to: 'components.multi.numberMultiplier.ports.inputs.secondNumberReceived'
    },
    {
      from: 'components.btn1.buttonTrigger.ports.outputs.buttonPressed',
      to: 'components.jsm1.jobStateMachine.ports.inputs.start'
    },
    {
      from: 'components.btn2.buttonTrigger.ports.outputs.buttonPressed',
      to: 'components.jsm1.jobStateMachine.ports.inputs.pause'
    },
    {
      from: 'components.btn3.buttonTrigger.ports.outputs.buttonPressed',
      to: 'components.jsm1.jobStateMachine.ports.inputs.resume'
    },
    {
      from: 'components.btn4.buttonTrigger.ports.outputs.buttonPressed',
      to: 'components.jsm1.jobStateMachine.ports.inputs.finish'
    },
    {
      from: 'components.btn5.buttonTrigger.ports.outputs.buttonPressed',
      to: 'components.jsm1.jobStateMachine.ports.inputs.reset'
    },
  ]
};

export default schema(flow);
</FILE>
<REQUEST>
flow.schema should reflect ports inputs and outputs
</REQUEST>