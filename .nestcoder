# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/flow-based-programming/src/bases/component.base.ts">
import { Inject, Injectable } from '@nestjs/common';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Component } from '../interfaces/component.interface';
import { CustomLogger } from '../logger/custom-logger';
import { WebSocketGateway, WebSocketServer, SubscribeMessage, MessageBody } from '@nestjs/websockets';
import { Server } from 'socket.io';
import * as ejs from 'ejs';
import * as path from 'path';
import { Connection } from 'src/interfaces/connection.interface';
import { Port } from 'src/interfaces/port.interface';
import { ComponentRegistry } from 'src/services/component-registry.service';

@WebSocketGateway()
@Injectable()
export abstract class ComponentBase implements Component {
  protected readonly logger: CustomLogger;
  public _ports: { inputs: Port[]; outputs: Port[]; };
  public ports: { inputs: string[]; outputs: string[]; };
  public _connections: Map<string, Component> = new Map();
  public connections: Connection[];

  constructor(
    public componentId: string,
    public slug: string,
    public description: string,
    public flowId: string,
    public componentRef: string,
    @Inject(AmqpConnection) protected amqpConnection: AmqpConnection,
    protected server: Server,
  ) {
    this.logger = new CustomLogger(this.componentId, amqpConnection);
  }

  abstract handleEvent(eventId: string, data: any): Promise<void>;

  async publish(flowId: string, componentId: string, eventId: string, data: any): Promise<void> {
    this.logger.log(`Publishing: ${flowId}.${componentId}.${eventId} -> ${data}`);
    if (!this.amqpConnection) {
      this.logger.error('AmqpConnection is not initialized');
      return;
    }
    await this.amqpConnection.publish('flow_exchange', 'componentEvent', {
      flowId,
      componentId,
      eventId,
      data,
    });
  }

  @SubscribeMessage('client-event')
  handleClientEvent(@MessageBody() data: any): void {
    const { flowId, componentId, eventId, ...eventData } = data;
    this.logger.log(`Received client event: flowId=${flowId}, componentId=${componentId}, eventId=${eventId}, data=${JSON.stringify(eventData)}`);
    this.publish(flowId, componentId, 'clientEventReceived', eventData);
  }

  public async display(flowId: string, componentId: string, templateId: string, data: any) {
    data._flowId = flowId;
    data._componentId = componentId;
    data._templateId = templateId;
    const htmxContent = await this.generateHtmxContent(data);
    
    if (this.server) {
      this.logger.log(htmxContent)
      this.server.emit('display-flow-component-template-content', {
        flowId,
        componentId,
        templateId,
        content: htmxContent
      });
    } else {
      this.logger.warn('WebSocket server is not initialized');
    }
  }

  private async generateHtmxContent(data: any): Promise<string> {
    const templatePath = path.resolve(__dirname, `../templates/${data._templateId}.ejs`);
    try {
      return await ejs.renderFile(templatePath, data);
    } catch (error) {
      this.logger.error(`Error rendering EJS template: ${error.message}`);
      return `<div>Error rendering content</div>`;
    }
  }

  public syncConnections(connections: Connection[], componentRegistry: ComponentRegistry): void {
    if (connections) {
      this.connections = [];
      connections.forEach((connection, index) => {
        // console.log('connection', connection);
        // console.log('this.componentRegistry', componentRegistry)
        if (connection.fromFlow === this.flowId && connection.fromComponent === this.componentId) {
          // console.log(`from is the current instance so register to instance`);
          const connectionKey = `${connection.fromEvent}>${connection.toFlow}.${connection.toComponent}.${connection.toEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.toFlow, connection.toComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = connectedComponentInstance;
          connection.connectedFrom = this;
          this.connections.push(connection);
        } else if (connection.toFlow === this.flowId && connection.toComponent === this.componentId) {
          // console.log(`to is the current instance so register from instance`);
          const connectionKey = `${connection.toEvent}>${connection.fromFlow}.${connection.fromComponent}.${connection.fromEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.fromFlow, connection.fromComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = this;
          connection.connectedFrom = connectedComponentInstance;
          this.connections.push(connection);
        } else {
          // connection does not match; do nothing.
        }
      })
    }
  }

  // TODO: addPort()

  // TODO: removePort()

  // TODO: connectComponentToPort()

  // TODO: disconnectComponentFromPort()

  public async getPorts(): Promise<{ inputs: Port[], outputs: Port[] }> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    let ports = {
      inputs: [],
      outputs: []
    }
    this.ports.inputs.forEach(async (input) => {
      let i = input.split('.');
      let port: Port = {
        direction: 'input',
        dataType: i[0],
        dataMethod: i[1] === 'display' ? 'display' : 'publish',
        eventId: i[2],
        connections: [...await this.loadConnections('input', i[2])]
      }
      ports.inputs.push(port);
    });
    this.ports.outputs.forEach(async (output) => {
      let o = output.split('.');
      let port: Port = {
        direction: 'output',
        dataType: o[0],
        dataMethod: o[1] === 'display' ? 'display' : 'publish',
        eventId: o[2],
        connections: [...await this.loadConnections('output', o[2])]
      }
      ports.outputs.push(port);
    });
    this._ports = ports;
    return ports;
  }

  private async loadConnections(direction: string, eventId: string): Promise<Connection[]> {
    let connections: Connection[] = [];
    // console.log('this.connections', this.connections);
    if (this.connections) {
      this.connections.forEach((connection: Connection) => {
        // console.log('connection', connection);
        if (direction === 'input') {
          if (connection.toEvent === eventId) {
            connections.push(connection);
          }
        } else {
          if (connection.fromEvent === eventId) {
            connections.push(connection);
          }
        }
      });
      return connections;
    } else {
      return [];
    }
  }

  public async findPort(portId: string): Promise<Port> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    const pId = portId.split('.');
    const eventId = pId[2];
    const ports = await this.getPorts();
    let port: Port;
    ports.inputs.forEach((input: Port) => {
      if (input.eventId === eventId) {
        port = input;
      }
    });
    ports.outputs.forEach((output: Port) => {
      if (output.eventId === eventId) {
        port = output;
      }
    });
    return port;
  }

  public async findConnections(port: Port): Promise<Connection[]> {
    if (port && port.connections) {
      return port.connections;
    }
    return [];
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/event-trigger/event-trigger.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';

import { triggerEvent } from './trigger-event.event';

@Injectable()
export class EventTriggerComponent extends ComponentBase {
  public logger;
  public ports = { // io format: <dataType>.<dataMethod>.<eventId>
    inputs: [
      'any.publish.triggerEvent',
    ],
    outputs: [
      'any.publish.any'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server
  ) {
    super('eventTrigger', 'event-trigger', 'Handles HTMX requests and triggers events', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    switch (eventId) {
      case 'triggerEvent':
        await this.triggerEvent(data);
        break;
      default:
        break;
    }
  }

  private async triggerEvent(data): Promise<void> {
    return await triggerEvent(this, data);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/event-trigger/trigger-event.event.ts">
import { EventTriggerComponent } from "./event-trigger.handler";

// networks of black box processes, which exchange data
// across predefined connections by message passing
export async function triggerEvent(process: EventTriggerComponent, message: any): Promise<void> {
  const { _flowId, _componentId, _eventId } = message;
  return await process.publish(_flowId, _componentId, _eventId, message);
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/state-machine/state-machine.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';

import { init } from './init.event';
import { initializeMachine } from './initialize-machine.event';
import { transition } from './transition.event';

@Injectable()
export class StateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  public currentState: string;
  public states: Set<string>;
  public transitions: Map<string, Map<string, string>>;
  
  public ports = {
    inputs: [
      'any.publish.initializeMachine',
      'any.publish.transition'
    ],
    outputs: [
      'any.publish.stateChanged',
      'htmx.display.state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server
  ) {
    super('stateMachine', 'state-machine', 'Implements a simple state machine', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
    this.states = new Set();
    this.transitions = new Map();
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "init": {
        await this.init(data);
        break;
      }
      case "initializeMachine": {
        await this.initializeMachine(data);
        break;
      }
      case "transition": {
        await this.transition(data);
        break;
      }
      default: {
        this.logger.warn(`Unknown event: ${eventId}`);
      }
    }
  }

  public async init(data: any): Promise<void> {
    return init(this, data);
  }

  public async initializeMachine(data: any): Promise<void> {
    return initializeMachine(this, data);
  }

  public async transition(data: any): Promise<void> {
    return transition(this, data);
  }

  public getCurrentState(): string {
    return this.currentState;
  }

  public getStates(): Set<string> {
    return this.states;
  }

  public getTransitions(): Map<string, Map<string, string>> {
    return this.transitions;
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/state-machine/transition.event.ts">
import { StateMachineComponent } from './state-machine.handler';

// networks of black box processes, which exchange data
// across predefined connections by message passing
export async function transition(process: StateMachineComponent, message: any): Promise<void> {
  const { event } = message;
  const currentState = process.currentState;

  const stateTransitions = process.transitions.get(currentState);
  if (!stateTransitions) {
    process.logger.warn(`No transitions defined for state: ${currentState}`);
    return;
  }

  const nextState = stateTransitions.get(event);
  if (!nextState) {
    process.logger.warn(`No transition defined for event '${event}' in state '${currentState}'`);
    return;
  }

  process.currentState = nextState;
  process.logger.log(`Transitioned from '${currentState}' to '${nextState}' on event '${event}'`);

  await process.publish(process.flowId, process.componentId, 'stateChanged', { 
    previousState: currentState,
    currentState: process.currentState,
    event
  });

  await process.display(process.flowId, process.componentId, 'state-machine', {
    currentState: process.currentState,
    states: Array.from(process.states),
    transitions: Object.fromEntries(process.transitions)
  });
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/component.interface.ts">
import { Connection } from "./connection.interface";
import { Port } from "./port.interface";

export interface Component {
  ports: { inputs: string[]; outputs: string[]; };
  componentRef: string;
  slug: string;
  description?: string;
  flowId: string;
  componentId: string;
  handleEvent: (eventId: string, data: any) => Promise<void>;
  publish: (flowId: string, componentId: string, eventId: string, data: any) => Promise<void>;
  getPorts: () => Promise<{ inputs: Port[], outputs: Port[] }>;
  findPort: (portId: string) => Promise<Port>;
  findConnections: (port: Port) => Promise<Connection[]>
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/port.interface.ts">
import { Connection } from "./connection.interface";

// portId format: <dataType>.<dataMethod>.<eventId>
export interface Port {
  direction: 'input' | 'output'
  dataType: string;
  dataMethod: 'display' | 'publish';
  eventId: string;
  connections: Connection[];
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/processors/event.processor.ts">
import { Injectable, Logger } from '@nestjs/common';
import { RabbitSubscribe } from '@golevelup/nestjs-rabbitmq';
import { ComponentRegistry } from '../services/component-registry.service';

@Injectable()
export class EventProcessor {
  private readonly logger = new Logger(EventProcessor.name);
  private connections: Map<string, { toFlow: string; toComponent: string; toEvent: string }> = new Map();

  constructor(private componentRegistry: ComponentRegistry) {}

  @RabbitSubscribe({
    exchange: 'flow_exchange',
    routingKey: 'componentEvent',
    queue: 'component_event_queue',
  })
  async handleComponentEvent(msg: {flowId: string, componentId: string, eventId: string, data: any}) {
    const { flowId, componentId, eventId, data: eventData } = msg;
    this.logger.log(`[handleComponentEvent] [${flowId}.${componentId}.${eventId}] data: ${JSON.stringify(eventData)}`);
    
    const component = this.componentRegistry.getComponent(flowId, componentId);
    if (component) {
      this.logger.log(`Passing event to component: ${componentId}`);
      await component.handleEvent(eventId, eventData);

      // Check if there's a connection for this event
      const connectionKey = `${flowId}.${componentId}.${eventId}`;
      const connection = this.connections.get(connectionKey);
      if (connection) {
        const { toFlow, toComponent, toEvent } = connection;
        this.logger.log(`[forwardingComponentEvent] [${toFlow}.${toComponent}.${toEvent}]`);
        
        const targetComponent = this.componentRegistry.getComponent(toFlow, toComponent);
        if (targetComponent) {
          this.logger.log(`Forwarding event to component: ${targetComponent.componentId}`);
          await targetComponent.handleEvent(toEvent, eventData);
        } else {
          this.logger.warn(`Target component not found: ${toComponent} in flow: ${toFlow}`);
        }
      }
    } else {
      this.logger.warn(`Component not found: ${flowId}.${componentId}`);
    }
  }

  @RabbitSubscribe({
    exchange: 'flow_exchange',
    routingKey: 'createConnection',
    queue: 'create_connection_queue',
  })
  async createConnection(msg: {flowId: string, fromComponent: string, fromEvent: string, toComponent: string, toEvent: string}) {
    const { flowId, fromComponent, fromEvent, toComponent, toEvent } = msg;
    this.logger.log(`Received createConnection: ${flowId}.${fromComponent}.${fromEvent} -> ${toComponent}.${toEvent}`);
    
    const connectionKey = `${flowId}.${fromComponent}.${fromEvent}`;
    this.connections.set(connectionKey, { toFlow: flowId, toComponent, toEvent });
    this.logger.log(`Connection created: ${connectionKey} -> ${toComponent}.${toEvent}`);
    
    return { success: true, message: 'Connection created successfully' };
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/services/component-registry.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { Component } from '../interfaces/component.interface';

@Injectable()
export class ComponentRegistry {
  private components: Map<string, Component> = new Map();
  private readonly logger = new Logger(ComponentRegistry.name);

  registerComponent(component: Component) {
    const key = `${component.flowId}.${component.componentId}`;
    this.logger.log(`Registering component: ${key}`);
    this.components.set(key, component);
  }

  getComponent(flowId: string, componentId: string): Component | undefined {
    const key = `${flowId}.${componentId}`;
    const component = this.components.get(key);
    if (!component) {
      this.logger.warn(`Component not found: ${key}`);
    }
    return component;
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/templates/event-trigger.ejs">
<div id="<%= _flowId %>.<%= _componentId %>.<%= _templateId %>" class="event-trigger-content">
  <h3>Event Triggered</h3>
  <p>Flow ID: <%= flowId %></p>
  <p>Component ID: <%= componentId %></p>
  <p>Template ID: <%= templateId %></p>
  <% if (typeof data === 'object') { %>
    <ul>
      <% for (const [key, value] of Object.entries(data)) { %>
        <li><strong><%= key %>:</strong> <%= value %></li>
      <% } %>
    </ul>
  <% } else { %>
    <p>Data: <%= data %></p>
  <% } %>
  <p>Timestamp: <%= new Date().toISOString() %></p>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/component.ejs">
<% if (component) { %>
  <div id="<%- component.flowId %>.<%- component.componentId %>">
    <div class="event-anchor input-anchors">
      <% component.ports.inputs.forEach((input, index) => { %>
        <% if (index !== 0) { %>
         <hr>
        <% } %>
        <button onclick="loadConnectedComponents('input', '<%- component.flowId %>', '<%- component.componentId %>', '<%- input %>', '<%- swimlaneId %>')">input</button>
        <div style="float: right;">
          <%- input %>
        </div>
        <br />
      <% }) %>
    </div>
    <div id="number-generator" class="component">
      <h2><%- component.componentId %> (<%- component.slug %>)</h2>
      <p><%- component.description %> </p>
      <button hx-post="/trigger-event/<%- component.flowId %>.<%- component.componentId %>.start"
        hx-swap="none" 
        hx-ext='json-enc'
        hx-headers='{"Content-Type": "application/json"}'
        hx-vals='{}'
      >
        Start Generating
      </button>
      <button hx-post="/trigger-event/<%- component.flowId %>.<%- component.componentId %>.stop"
        hx-swap="none" 
        hx-ext='json-enc'
        hx-headers='{"Content-Type": "application/json"}'
        hx-vals='{}'
      >
        Stop Generating
      </button>
    </div>
    <div class="event-anchor output-anchors">
      <% component.ports.outputs.forEach((output, index) => { %>
        <% if (index !== 0) { %>
         <hr>
        <% } %>
        <button onclick="loadConnectedComponents('output', '<%- component.flowId %>', '<%- component.componentId %>', '<%- output %>', '<%- swimlaneId %>')" style="float: right;">output</button>
        <%- output %> <br />
      <% }) %>
    </div>
  </div>
<% } else { %>
  <p>no component found</p>  
<% } %>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/connections.ejs">
<div id="<%- flowId %>.<%- componentId %>.<%- portId %>" class="swimlane-content" data-swimlane-id="<%- swimlaneId %>">
  <% if (port && port.dataMethod) { %>
    <% if (port.dataMethod === 'publish') { %>
      <% if (connections.length) { %>
        <% connections.forEach(connection => { %>
          <%- include('component', { component: connection.next, swimlaneId }); %> 
        <% }) %>
      <% } else { %>
        <br />
        <div class="component">no connections found</div>  
      <% } %>
    <% } %>
  
    <% if (port.dataMethod === 'display') { %>
      <div id="<%- flowId %>.<%- componentId %>">
        <div class="event-anchor input-anchors">
          <button onclick="loadMainComponent('input', '<%- flowId %>', '<%- componentId %>', '<%- swimlaneId %>')">input</button>
          <div style="float: right;">
            <%- portId %> 
          </div>
          <br>
        </div>
        <div class="component">
          <div id="<%- displayHtmxId %>"></div>
        </div>
      </div>
    <% } %>
  <% } else { %>
    <div>component not found</div>  
  <% } %>
</div>

</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/index.ejs">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%- message %></title>
  <script src="https://unpkg.com/htmx.org@2.0.2"></script>
  <script src="https://unpkg.com/htmx.org@1.9.12/dist/ext/json-enc.js"></script>
  <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script>
  <%- include('style') %> 
</head>
<body>
  <br />
  <br />
  <br />
  <%- include('main') %> 
  <br />
  <br />
  <br />

  <script>
    const socket = io();

    socket.on('display-flow-component-template-content', function(event) {
      const targetId = `${event.flowId}.${event.componentId}.${event.templateId}`;
      const targetElement = document.getElementById(targetId);
      if (targetElement) {
        targetElement.outerHTML = event.content;
      }
    });

    htmx.on("htmx:configRequest", (event) => {
      event.detail.headers['Content-Type'] = 'application/json';
    });
  </script>
</body>
</html>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/main.ejs">
<main>
  <h1>FBP Steam Engine</h1>
  <p>The complete Flow-based Programming solution:</p>
  <div style="overflow: hidden;">
    <ul class="navigation">
      <li><a href="/chart"><button>chart</button></a></li>
      <li><a href="/document"><button>document</button></a></li>
      <li><a href="/logger"><button>logger</button></a></li>
    </ul>
  </div>
  <p>
    > min 1 screen per part & min 3 parts per system/app.<br />
    > *ideal for domain specific languages*
  </p>
  <hr>
  <p>
    What is FBP? Is it time for a new Steam Engine?<br />
    <a href="https://www.youtube.com/watch?v=up2yhNTsaDs" target="_blank">https://www.youtube.com/watch?v=up2yhNTsaDs</a>
  </p>  
  <p>
    Fork this FBP Steam Engine repository for each application.<br />
    <a href="https://github.com/subvind/flow-based-programming" target="_blank">https://github.com/subvind/flow-based-programming</a>
  </p>
  <span>~made with &hearts; by <a href="https://istrav.com">isTrav</a> & <a href="https://subvind.com">subVind</a> + ai :)</span>
</main>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/style.ejs">

<style>
  body { 
    font-family: Arial, sans-serif; 
    margin: 0; 
    padding: 20px;
    background: #eee; 
  }
  main {
    border: 1px solid #111;
    margin: 0 auto;
    max-width: 600px;
    padding: 1em;
    background: #fff;
  }
  h1 {
    margin: 0;
  }
  .navigation {
    margin: 0;
    padding: 0;
    list-style: none outside none;
    position: relative;
  }
  .navigation li {
    margin: 0 0.5em 0.5em 0;
    list-style-type: none;
    float: left;
  }
  .navigation li button {
    font-size: 1.2em;
  }
</style>
</FILE>
<FILE path="src/components/button-trigger/button-trigger.handler.ts" TARGET>
(empty file)
</FILE>
<REQUEST>
create a button tigeer that is similar in structure to the  other components ... it works with sending events to state machines to toggle their state and has ui button in htmx that uses event-trigger
</REQUEST>