# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/flow-based-programming/src/templates/button-trigger.ejs">
<div id="<%= _flowId %>.<%= _componentId %>.<%= _templateId %>" class="button-trigger-content">
  <h3>Button Trigger</h3>
  <button hx-post="/trigger-event/<%= _flowId %>.<%= _componentId %>.triggerButton"
          hx-swap="none"
          hx-ext="json-enc"
          hx-headers='{"Content-Type": "application/json"}'
          hx-vals='{"targetFlow": "<%= targetFlow %>", "targetComponent": "<%= targetComponent %>", "targetEvent": "<%= targetEvent %>"}'
  >
    Trigger Event
  </button>
  <% if (lastPressed) { %>
    <p>Last pressed: <%= lastPressed %></p>
  <% } %>
  <p>Target: <%= targetFlow %>.<%= targetComponent %>.<%= targetEvent %></p>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/component.interface.ts">
import { Connection } from "./connection.interface";
import { Port } from "./port.interface";

export interface Component {
  ports: { inputs: string[]; outputs: string[]; };
  componentRef: string;
  slug: string;
  description?: string;
  flowId: string;
  componentId: string;
  handleEvent: (eventId: string, data: any) => Promise<void>;
  publish: (flowId: string, componentId: string, eventId: string, data: any) => Promise<void>;
  getPorts: () => Promise<{ inputs: Port[], outputs: Port[] }>;
  findPort: (portId: string) => Promise<Port>;
  findConnections: (port: Port) => Promise<Connection[]>
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/services/template-cache.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class TemplateCacheService {
  private cache: Map<string, string> = new Map();

  setTemplate(key: string, content: string): void {
    this.cache.set(key, content);
  }

  getTemplate(key: string): string | undefined {
    return this.cache.get(key);
  }

  hasTemplate(key: string): boolean {
    return this.cache.has(key);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/templates/event-trigger.ejs">
<div id="<%= _flowId %>.<%= _componentId %>.<%= _templateId %>" class="event-trigger-content">
  <h3>Event Triggered</h3>
  <p>Flow ID: <%= flowId %></p>
  <p>Component ID: <%= componentId %></p>
  <p>Template ID: <%= templateId %></p>
  <% if (typeof data === 'object') { %>
    <ul>
      <% for (const [key, value] of Object.entries(data)) { %>
        <li><strong><%= key %>:</strong> <%= value %></li>
      <% } %>
    </ul>
  <% } else { %>
    <p>Data: <%= data %></p>
  <% } %>
  <p>Timestamp: <%= new Date().toISOString() %></p>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/templates/job-state-machine.ejs">
<div id="<%= _flowId %>.<%= _componentId %>.<%= _templateId %>" class="job-state-machine-content">
  <h3>Job State Machine</h3>
  <p>Current Job State: <strong><%= currentState %></strong></p>
  <h4>Job States:</h4>
  <ul>
    <% states.forEach(function(state) { %>
      <li><%= state %></li>
    <% }); %>
  </ul>
  <h4>Job Transitions:</h4>
  <ul>
    <% for (const [fromState, events] of Object.entries(transitions)) { %>
      <li>
        <%= fromState %>:
        <ul>
          <% for (const [event, toState] of Object.entries(events)) { %>
            <li><%= event %> -> <%= toState %></li>
          <% } %>
        </ul>
      </li>
    <% } %>
  </ul>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/templates/number-generator.ejs">
<div id="<%= _flowId %>.<%= _componentId %>.<%= _templateId %>">
  <p>Last generated number: <%= number %></p>
  <p>Generated at: <%= new Date(timestamp).toLocaleString() %></p>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/templates/number-multiplier.ejs">
<div id="<%= _flowId %>.<%= _componentId %>.<%= _templateId %>">
  <p>First number: <%= firstNumber !== null ? firstNumber : 'Waiting...' %></p>
  <p>Second number: <%= secondNumber !== null ? secondNumber : 'Waiting...' %></p>
  <p>Multiplied result: <%= result !== undefined ? result : 'Waiting for both numbers...' %></p>
  <p>Processed at: <%= new Date(timestamp).toLocaleString() %></p>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/templates/state-machine.ejs">
<div id="<%= _flowId %>.<%= _componentId %>.<%= _templateId %>" class="state-machine-content">
  <h3>State Machine</h3>
  <p>Current State: <strong><%= currentState %></strong></p>
  <h4>States:</h4>
  <ul>
    <% states.forEach(function(state) { %>
      <li><%= state %></li>
    <% }); %>
  </ul>
  <h4>Transitions:</h4>
  <ul>
    <% for (const [fromState, events] of Object.entries(transitions)) { %>
      <li>
        <%= fromState %>:
        <ul>
          <% for (const [event, toState] of Object.entries(events)) { %>
            <li><%= event %> -> <%= toState %></li>
          <% } %>
        </ul>
      </li>
    <% } %>
  </ul>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/connections.ejs">
<div id="<%- flowId %>.<%- componentId %>.<%- portId %>" class="swimlane-content" data-swimlane-id="<%- swimlaneId %>">
  <% if (port && port.dataMethod) { %>
    <% if (port.dataMethod === 'publish') { %>
      <% if (connections.length) { %>
        <% connections.forEach(connection => { %>
          <%- include('component', { component: connection.next, swimlaneId }); %> 
        <% }) %>
      <% } else { %>
        <br />
        <div class="component">no connections found</div>  
      <% } %>
    <% } %>
  
    <% if (port.dataMethod === 'display') { %>
      <div id="<%- flowId %>.<%- componentId %>">
        <div class="event-anchor input-anchors">
          <button onclick="loadMainComponent('input', '<%- flowId %>', '<%- componentId %>', '<%- swimlaneId %>')">input</button>
          <div style="float: right;">
            <%- portId %> 
          </div>
          <br>
        </div>
        <div class="component">
          <%- templateContent %>
        </div>
      </div>
    <% } %>
  <% } else { %>
    <div>component not found</div>  
  <% } %>
</div>

</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/methods.ejs">
<script>
  function getNextSwimlane(direction, mainSwimlane) {
    const mainIndex = parseInt(mainSwimlane.getAttribute('data-index'));
    
    let targetIndex, targetSwimlane;
    if (direction === 'input') {
      targetIndex = mainIndex - 1;
      targetSwimlane = getOrCreateSwimlane(targetIndex);
    } else {
      targetIndex = mainIndex + 1;
      targetSwimlane = getOrCreateSwimlane(targetIndex);
    }

    return {
      mainIndex,
      targetIndex,
      targetSwimlane
    }
  }

  function loadConnectedComponents(direction, flowId, componentId, port, swimlaneId) {
    console.log('swimload load connected', swimlaneId, direction);
    const mainSwimlane = document.getElementById(swimlaneId);
    let next = getNextSwimlane(direction, mainSwimlane);

    const key = `${flowId}.${componentId}.${port}`;
    const eventElement = document.createElement('div');
    eventElement.setAttribute("id", key);
    next.targetSwimlane.innerHTML = '';
    next.targetSwimlane.appendChild(eventElement);
    
    htmx.ajax('GET', `/documentConnections/${flowId}/${componentId}/${port}/${next.targetSwimlane.id}`, {
      swap: 'none',
      handler: (dom, event) => {
        document.getElementById(key).outerHTML = event.xhr.response;
        htmx.process(document.getElementById(key));
      }
    });
  }

  function loadMainComponent(direction, flowId, componentId, swimlaneId) {
    console.log('swimload load main', swimlaneId, direction);
    // Update the main swimlane
    const mainSwimlane = document.getElementById(swimlaneId);
    let next = getNextSwimlane(direction, mainSwimlane);
    next.targetSwimlane.innerHTML = '';
    
    htmx.ajax('GET', `/documentComponent/${flowId}/${componentId}/${next.targetSwimlane.id}`, {
      swap: 'none',
      handler: (dom, event) => {
        next.targetSwimlane.innerHTML = event.xhr.response;
      }
    });
  }

  function getOrCreateSwimlane(index) {
    let swimlane = document.querySelector(`.swimlane[data-index="${index}"]`);
    if (swimlane) {
      console.log('swimlane found', index, swimlane)
    } else {
      console.log('swimlane not found', index)
    }
    if (!swimlane) {
      swimlane = document.createElement('div');
      swimlane.className = 'swimlane';
      swimlane.setAttribute('data-index', index);
      swimlane.id = `swimlane-${index}`;
      
      const container = document.getElementById('swimlane-container');
      if (index < 0) {
        container.insertBefore(swimlane, container.firstChild);
      } else {
        container.appendChild(swimlane);
      }
    }
    return swimlane;
  }
</script>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/style.ejs">
<style>
  h2 { margin-top: 0; }
  
  body {
    font-family: Arial, sans-serif; 
    margin: 0; 
    padding: 0;
    background: #eee; 
  }
  .swimlane-container {
    display: flex;
    overflow-x: auto;
    width: 100%;
    height: 100vh;
  }
  .swimlane {
    flex: 0 0 33.33%;
    min-width: 300px;
    padding: 0 2em;
    border-right: 4px dashed #ccc;
    overflow-y: auto;
  }
  .input-swimlane, .output-swimlane {
    width: 33.33%; 
    width: calc(100%/3);
    height: 100%;
    padding: 0 1em;

  }
  .input-swimlane {
    border-right: 5px dashed #ccc;
  }
  .output-swimlane {
    border-left: 5px dashed #ccc;
  }
  .main-swimlane {
    width: 33.33%; 
    width: calc(100%/3);
    padding: 0 1em;
    height: 100%;
    overflow-y: auto;
  }
  .component {
    background: #fff; 
    border: 1px solid #111; 
    padding: 10px; 
    margin-bottom: 10px; 
    position: relative;
  }
  .input-anchors { 
    margin-top: 1em;
    background: #fff; 
    border: 1px solid #111;
    padding: 0.5em; 
    margin-bottom: 10px; 
  }
  .input-anchor-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
  }
  .input-anchor-row button {
    flex: 1;
    margin: 0 2px;
  }
  .output-anchors { 
    margin-bottom: 1em;
    background: #fff; 
    border: 1px solid #111; 
    padding: 0.5em; 
  }
  .output-anchor-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
  }
  .output-anchor-row button {
    flex: 1;
    margin: 0 2px;
  }

  .container {
    display: flex;
    height: 100vh;
  }

  .sidebar {
    min-width: 300px;
    background-color: #fff;
    padding: 0.5em;
    overflow-y: auto;
    border-right: 1px solid #111;
  }

  .main-content {
    flex-grow: 1;
    overflow-y: auto;
  }

  .sidebar-selector h3 {
    margin-top: 0;
    margin: 0 0 0.4em;
  }

  .sidebar-selector ul {
    list-style-type: none;
    padding: 0;
    margin: 0;
  }

  .sidebar-selector li {
    border-top: 1px solid #eee;
    padding: 0.3em 0;
  }

  .sidebar-selector a {
    text-decoration: none;
    color: #333;
  }

  .sidebar-selector a:hover {
    text-decoration: underline;
  }
</style>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/view.ejs">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%- message %></title>
  <script src="https://unpkg.com/htmx.org@2.0.2"></script>
  <script src="https://unpkg.com/htmx.org@1.9.12/dist/ext/json-enc.js"></script>
  <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script>
  <%- include('style') %>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <%- include('component-selector', { flowId: selected.flowId, componentId: selected.componentId, components: components }) %>
    </div>
    <div class="main-content">
      <div id="swimlane-container" class="swimlane-container">
        <div id="main-swimlane" class="swimlane" data-index="0"
             hx-get="/documentComponent/<%= selected.flowId %>/<%= selected.componentId %>/main-swimlane"
             hx-trigger="load"
             hx-target="#main-swimlane">
          <!-- Main component will be loaded here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    const socket = io();

    socket.on('display-flow-component-template-content', function(event) {
      const targetId = `${event.flowId}.${event.componentId}.${event.templateId}`;
      const targetElement = document.getElementById(targetId);
      console.log('display-flow-component-template-content', targetId);
      if (targetElement) {
        targetElement.outerHTML = event.content;
        // Reinitialize HTMX on the new content
        htmx.process(document.getElementById(targetId));
      }
    });

    htmx.on("htmx:configRequest", (event) => {
      event.detail.headers['Content-Type'] = 'application/json';
    });
  </script>
  <%- include('methods') %> 
</body>
</html>
</FILE>
<FILE path="src/views/document/component.ejs" TARGET>
<% if (component) { %>
  <div id="<%- component.flowId %>.<%- component.componentId %>">
    <div class="event-anchor input-anchors">
      <% component.ports.inputs.forEach((input, index) => { %>
        <% if (index !== 0) { %>
         <hr>
        <% } %>
        <button onclick="loadConnectedComponents('input', '<%- component.flowId %>', '<%- component.componentId %>', '<%- input %>', '<%- swimlaneId %>')">input</button>
        <div style="float: right;">
          <%- input %>
        </div>
        <br />
      <% }) %>
    </div>
    <div id="number-generator" class="component">
      <h2 style="margin: 0;"><%- component.componentId %> (<%- component.slug %>)</h2>
      <p style="margin: 0 0 0.5em;"><%- component.description %> </p>
      <div style="border: 1px solid #111;">
        <br>
        <!-- TODO: if componentRef is button-trigger then load the related flow-component-template button-trigger here -->
      </div>
    </div>
    <div class="event-anchor output-anchors">
      <% component.ports.outputs.forEach((output, index) => { %>
        <% if (index !== 0) { %>
         <hr>
        <% } %>
        <button onclick="loadConnectedComponents('output', '<%- component.flowId %>', '<%- component.componentId %>', '<%- output %>', '<%- swimlaneId %>')" style="float: right;">output</button>
        <%- output %> <br />
      <% }) %>
    </div>
  </div>
<% } else { %>
  <p>no component found</p>  
<% } %>
</FILE>
<REQUEST>
TODO: if componentRef is button-trigger then load the related flow-component-template button-trigger here
</REQUEST>