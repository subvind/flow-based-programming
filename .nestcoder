# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/flow-based-programming/src/bases/component.base.ts">
import { Inject, Injectable } from '@nestjs/common';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Component } from '../interfaces/component.interface';
import { CustomLogger } from '../logger/custom-logger';
import { WebSocketGateway, WebSocketServer, SubscribeMessage, MessageBody } from '@nestjs/websockets';
import { Server } from 'socket.io';
import * as ejs from 'ejs';
import * as path from 'path';
import { Connection } from 'src/interfaces/connection.interface';
import { Port } from 'src/interfaces/port.interface';
import { ComponentRegistry } from 'src/services/component-registry.service';

@WebSocketGateway()
@Injectable()
export abstract class ComponentBase implements Component {
  protected readonly logger: CustomLogger;
  public _ports: { inputs: Port[]; outputs: Port[]; };
  public ports: { inputs: string[]; outputs: string[]; };
  public _connections: Map<string, Component> = new Map();
  public connections: Connection[];

  constructor(
    public componentId: string,
    public slug: string,
    public description: string,
    public flowId: string,
    public componentRef: string,
    @Inject(AmqpConnection) protected amqpConnection: AmqpConnection,
    protected server: Server,
  ) {
    this.logger = new CustomLogger(this.componentId, amqpConnection);
  }

  abstract handleEvent(eventId: string, data: any): Promise<void>;

  async publish(flowId: string, componentId: string, eventId: string, data: any): Promise<void> {
    this.logger.log(`Publishing: ${flowId}.${componentId}.${eventId} -> ${data}`);
    if (!this.amqpConnection) {
      this.logger.error('AmqpConnection is not initialized');
      return;
    }
    await this.amqpConnection.publish('flow_exchange', 'componentEvent', {
      flowId,
      componentId,
      eventId,
      data,
    });
  }

  @SubscribeMessage('client-event')
  handleClientEvent(@MessageBody() data: any): void {
    const { flowId, componentId, eventId, ...eventData } = data;
    this.logger.log(`Received client event: flowId=${flowId}, componentId=${componentId}, eventId=${eventId}, data=${JSON.stringify(eventData)}`);
    this.publish(flowId, componentId, 'clientEventReceived', eventData);
  }

  public async display(flowId: string, componentId: string, templateId: string, data: any) {
    data._flowId = flowId;
    data._componentId = componentId;
    data._templateId = templateId;
    const htmxContent = await this.generateHtmxContent(data);
    
    if (this.server) {
      this.logger.log(htmxContent)
      this.server.emit('display-flow-component-template-content', {
        flowId,
        componentId,
        templateId,
        content: htmxContent
      });
    } else {
      this.logger.warn('WebSocket server is not initialized');
    }
  }

  private async generateHtmxContent(data: any): Promise<string> {
    const templatePath = path.resolve(__dirname, `../templates/${data._templateId}.ejs`);
    try {
      return await ejs.renderFile(templatePath, data);
    } catch (error) {
      this.logger.error(`Error rendering EJS template: ${error.message}`);
      return `<div>Error rendering content</div>`;
    }
  }

  public syncConnections(connections: Connection[], componentRegistry: ComponentRegistry): void {
    if (connections) {
      this.connections = [];
      connections.forEach((connection, index) => {
        // console.log('connection', connection);
        // console.log('this.componentRegistry', componentRegistry)
        if (connection.fromFlow === this.flowId && connection.fromComponent === this.componentId) {
          // console.log(`from is the current instance so register to instance`);
          const connectionKey = `${connection.fromEvent}>${connection.toFlow}.${connection.toComponent}.${connection.toEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.toFlow, connection.toComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = connectedComponentInstance;
          connection.connectedFrom = this;
          this.connections.push(connection);
        } else if (connection.toFlow === this.flowId && connection.toComponent === this.componentId) {
          // console.log(`to is the current instance so register from instance`);
          const connectionKey = `${connection.toEvent}>${connection.fromFlow}.${connection.fromComponent}.${connection.fromEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.fromFlow, connection.fromComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = this;
          connection.connectedFrom = connectedComponentInstance;
          this.connections.push(connection);
        } else {
          // connection does not match; do nothing.
        }
      })
    }
  }

  // TODO: addPort()

  // TODO: removePort()

  // TODO: connectComponentToPort()

  // TODO: disconnectComponentFromPort()

  public async getPorts(): Promise<{ inputs: Port[], outputs: Port[] }> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    let ports = {
      inputs: [],
      outputs: []
    }
    this.ports.inputs.forEach(async (input) => {
      let i = input.split('.');
      let port: Port = {
        direction: 'input',
        dataType: i[0],
        dataMethod: i[1] === 'display' ? 'display' : 'publish',
        eventId: i[2],
        connections: [...await this.loadConnections('input', i[2])]
      }
      ports.inputs.push(port);
    });
    this.ports.outputs.forEach(async (output) => {
      let o = output.split('.');
      let port: Port = {
        direction: 'output',
        dataType: o[0],
        dataMethod: o[1] === 'display' ? 'display' : 'publish',
        eventId: o[2],
        connections: [...await this.loadConnections('output', o[2])]
      }
      ports.outputs.push(port);
    });
    this._ports = ports;
    return ports;
  }

  private async loadConnections(direction: string, eventId: string): Promise<Connection[]> {
    let connections: Connection[] = [];
    // console.log('this.connections', this.connections);
    if (this.connections) {
      this.connections.forEach((connection: Connection) => {
        // console.log('connection', connection);
        if (direction === 'input') {
          if (connection.toEvent === eventId) {
            connections.push(connection);
          }
        } else {
          if (connection.fromEvent === eventId) {
            connections.push(connection);
          }
        }
      });
      return connections;
    } else {
      return [];
    }
  }

  public async findPort(portId: string): Promise<Port> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    const pId = portId.split('.');
    const eventId = pId[2];
    const ports = await this.getPorts();
    let port: Port;
    ports.inputs.forEach((input: Port) => {
      if (input.eventId === eventId) {
        port = input;
      }
    });
    ports.outputs.forEach((output: Port) => {
      if (output.eventId === eventId) {
        port = output;
      }
    });
    return port;
  }

  public async findConnections(port: Port): Promise<Connection[]> {
    if (port && port.connections) {
      return port.connections;
    }
    return [];
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/state-machine/state-machine.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';

import { init } from './init.event';
import { initializeMachine } from './initialize-machine.event';
import { transition } from './transition.event';

@Injectable()
export class StateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  public currentState: string;
  public states: Set<string>;
  public transitions: Map<string, Map<string, string>>;
  
  public ports = {
    inputs: [
      'any.publish.initializeMachine',
      'any.publish.transition'
    ],
    outputs: [
      'any.publish.stateChanged',
      'htmx.display.state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server
  ) {
    super('stateMachine', 'state-machine', 'Implements a simple state machine', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
    this.states = new Set();
    this.transitions = new Map();
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "init": {
        await this.init(data);
        break;
      }
      case "initializeMachine": {
        await this.initializeMachine(data);
        break;
      }
      case "transition": {
        await this.transition(data);
        break;
      }
      default: {
        this.logger.warn(`Unknown event: ${eventId}`);
      }
    }
  }

  public async init(data: any): Promise<void> {
    return init(this, data);
  }

  public async initializeMachine(data: any): Promise<void> {
    return initializeMachine(this, data);
  }

  public async transition(data: any): Promise<void> {
    return transition(this, data);
  }

  public getCurrentState(): string {
    return this.currentState;
  }

  public getStates(): Set<string> {
    return this.states;
  }

  public getTransitions(): Map<string, Map<string, string>> {
    return this.transitions;
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/state-machine/initialize-machine.event.ts">
import { StateMachineComponent } from './state-machine.handler';

// networks of black box processes, which exchange data
// across predefined connections by message passing
export async function initializeMachine(process: StateMachineComponent, message: any): Promise<void> {
  const { initialState, states, transitions } = message;

  process.currentState = initialState;
  process.states = new Set(states);
  
  process.transitions = new Map();
  for (const [fromState, events] of Object.entries(transitions)) {
    process.transitions.set(fromState, new Map(Object.entries(events as Record<string, string>)));
  }

  process.logger.log(`State machine initialized with initial state: ${process.currentState}`);
  
  await process.publish(process.flowId, process.componentId, 'stateChanged', { 
    currentState: process.currentState 
  });

  await process.display(process.flowId, process.componentId, 'state-machine', {
    currentState: process.currentState,
    states: Array.from(process.states),
    transitions: Object.fromEntries(process.transitions)
  });
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/state-machine/transition.event.ts">
import { StateMachineComponent } from './state-machine.handler';

// networks of black box processes, which exchange data
// across predefined connections by message passing
export async function transition(process: StateMachineComponent, message: any): Promise<void> {
  const { event } = message;
  const currentState = process.currentState;

  const stateTransitions = process.transitions.get(currentState);
  if (!stateTransitions) {
    process.logger.warn(`No transitions defined for state: ${currentState}`);
    return;
  }

  const nextState = stateTransitions.get(event);
  if (!nextState) {
    process.logger.warn(`No transition defined for event '${event}' in state '${currentState}'`);
    return;
  }

  process.currentState = nextState;
  process.logger.log(`Transitioned from '${currentState}' to '${nextState}' on event '${event}'`);

  await process.publish(process.flowId, process.componentId, 'stateChanged', { 
    previousState: currentState,
    currentState: process.currentState,
    event
  });

  await process.display(process.flowId, process.componentId, 'state-machine', {
    currentState: process.currentState,
    states: Array.from(process.states),
    transitions: Object.fromEntries(process.transitions)
  });
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/logger/custom-logger.ts">
import { ConsoleLogger, Injectable, Inject } from '@nestjs/common';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class CustomLogger extends ConsoleLogger {
  constructor(
    private logId: string,
    @Inject(AmqpConnection) private amqpConnection: AmqpConnection
  ) {
    super(logId);
    this.setLogLevels(['log', 'error', 'warn', 'debug', 'verbose']);
  }

  log(message: string, context?: string) {
    this.printMessage(message, 'log', context);
    // this.emitLogEvent('log', message);
  }

  warn(message: string, context?: string) {
    this.printMessage(message, 'warn', context);
    // this.emitLogEvent('warn', message);
  }

  error(message: string, trace?: string, context?: string) {
    this.printMessage(message, 'error', context);
    // this.emitLogEvent('error', message);
    if (trace) {
      this.printMessage(trace, 'error', context);
    }
  }

  debug(message: string, context?: string) {
    this.printMessage(message, 'debug', context);
  }

  verbose(message: string, context?: string) {
    this.printMessage(message, 'verbose', context);
  }

  private printMessage(message: string, logLevel: string, context?: string) {
    const output = context ? `[${context}] ${message}` : message;
    console.log(`[${this.getNow()}] [${logLevel.toUpperCase()}] [${this.logId}] ${output}`);
  }

  private getNow(): string {
    return new Date().toISOString();
  }

  static write_to_file(message: string) {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    fs.appendFile(logFile, message, (err) => {
      if (err) {
        console.error('Failed to write to log file:', err);
      }
    });
  }

  static clearSTDOUT() {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    try {
      fs.writeFileSync(logFile, '');
      console.log(`Log file cleared at ${logFile}`);
    } catch (error) {
      console.error('Failed to clear log file:', error);
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/component.interface.ts">
import { Connection } from "./connection.interface";
import { Port } from "./port.interface";

export interface Component {
  ports: { inputs: string[]; outputs: string[]; };
  componentRef: string;
  slug: string;
  description?: string;
  flowId: string;
  componentId: string;
  handleEvent: (eventId: string, data: any) => Promise<void>;
  publish: (flowId: string, componentId: string, eventId: string, data: any) => Promise<void>;
  getPorts: () => Promise<{ inputs: Port[], outputs: Port[] }>;
  findPort: (portId: string) => Promise<Port>;
  findConnections: (port: Port) => Promise<Connection[]>
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/flow.interface.ts">
import { Connection } from "./connection.interface";

export interface Flow {
  id: string;
  components: {
    componentId: string;
    componentRef: string;
    init: any | undefined;
  }[];
  connections: Connection[];
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/state-machine.interface.ts">
import { Component } from "./component.interface";

export interface StateMachine extends Component {
  initializeMachine: (data: any) => Promise<void>;
  getCurrentState: () => string;
  getStates: () => Set<string>;
  getTransitions: () => Map<string, Map<string, string>>;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/templates/job-state-machine.ejs">
<div id="<%= _flowId %>.<%= _componentId %>.<%= _templateId %>" class="job-state-machine-content">
  <h3>Job State Machine</h3>
  <p>Current Job State: <strong><%= currentState %></strong></p>
  <h4>Job States:</h4>
  <ul>
    <% states.forEach(function(state) { %>
      <li><%= state %></li>
    <% }); %>
  </ul>
  <h4>Job Transitions:</h4>
  <ul>
    <% for (const [fromState, events] of Object.entries(transitions)) { %>
      <li>
        <%= fromState %>:
        <ul>
          <% for (const [event, toState] of Object.entries(events)) { %>
            <li><%= event %> -> <%= toState %></li>
          <% } %>
        </ul>
      </li>
    <% } %>
  </ul>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/node_modules/@golevelup/nestjs-rabbitmq/lib/amqp/connection.d.ts">
import { ChannelWrapper, AmqpConnectionManager } from 'amqp-connection-manager';
import { ConsumeMessage, Channel, Connection, ConfirmChannel, Options } from 'amqplib';
import { MessageHandlerOptions, RabbitMQConfig, RequestOptions, ConsumeOptions } from '../rabbitmq.interfaces';
import { RpcResponse, SubscribeResponse } from './handlerResponses';
export type ConsumerTag = string;
export type SubscriberHandler<T = unknown> = (msg: T | undefined, rawMessage?: ConsumeMessage, headers?: any) => Promise<SubscribeResponse>;
export interface CorrelationMessage {
    correlationId: string;
    requestId?: string;
    message: Record<string, unknown>;
}
export interface SubscriptionResult {
    consumerTag: ConsumerTag;
}
export type BaseConsumerHandler = {
    consumerTag: string;
    channel: ConfirmChannel;
};
export type ConsumerHandler<T, U> = (BaseConsumerHandler & {
    type: 'subscribe';
    msgOptions: MessageHandlerOptions;
    handler: (msg: T | undefined, rawMessage?: ConsumeMessage, headers?: any) => Promise<SubscribeResponse>;
}) | (BaseConsumerHandler & {
    type: 'rpc';
    rpcOptions: MessageHandlerOptions;
    handler: (msg: T | undefined, rawMessage?: ConsumeMessage, headers?: any) => Promise<RpcResponse<U>>;
});
export declare class AmqpConnection {
    private readonly messageSubject;
    private readonly logger;
    private readonly initialized;
    private _managedConnection;
    /**
     * Will now specify the default managed channel.
     */
    private _managedChannel;
    private _managedChannels;
    /**
     * Will now specify the default channel.
     */
    private _channel;
    private _channels;
    private _connection?;
    private _consumers;
    private readonly config;
    private readonly outstandingMessageProcessing;
    constructor(config: RabbitMQConfig);
    get channel(): Channel;
    get connection(): Connection;
    get managedChannel(): ChannelWrapper;
    get managedConnection(): AmqpConnectionManager;
    get configuration(): Required<RabbitMQConfig>;
    get channels(): Record<string, ConfirmChannel>;
    get managedChannels(): Record<string, import("amqp-connection-manager/dist/types/ChannelWrapper").default>;
    get connected(): boolean;
    init(): Promise<void>;
    private initCore;
    private setupInitChannel;
    private setupQueuesWithBindings;
    private initDirectReplyQueue;
    request<T>(requestOptions: RequestOptions): Promise<T>;
    createSubscriber<T>(handler: SubscriberHandler<T>, msgOptions: MessageHandlerOptions, originalHandlerName: string, consumeOptions?: ConsumeOptions): Promise<SubscriptionResult>;
    /**
     * Wrap a consumer with logic that tracks the outstanding message processing to
     * be able to wait for them on shutdown.
     */
    private wrapConsumer;
    private setupSubscriberChannel;
    createRpc<T, U>(handler: (msg: T | undefined, rawMessage?: ConsumeMessage, headers?: any) => Promise<RpcResponse<U>>, rpcOptions: MessageHandlerOptions): Promise<SubscriptionResult>;
    setupRpcChannel<T, U>(handler: (msg: T | undefined, rawMessage?: ConsumeMessage, headers?: any) => Promise<RpcResponse<U>>, rpcOptions: MessageHandlerOptions, channel: ConfirmChannel): Promise<ConsumerTag>;
    publish<T = any>(exchange: string, routingKey: string, message: T, options?: Options.Publish): Promise<boolean>;
    private handleMessage;
    private setupQueue;
    private setupManagedChannel;
    /**
     * Selects managed channel based on name, if not found uses default.
     * @param name name of the channel
     * @returns channel wrapper
     */
    private selectManagedChannel;
    private registerConsumerForQueue;
    private unregisterConsumerForQueue;
    private getConsumer;
    get consumerTags(): string[];
    cancelConsumer(consumerTag: ConsumerTag): Promise<void>;
    resumeConsumer<T, U>(consumerTag: ConsumerTag): Promise<ConsumerTag | null>;
    close(): Promise<void>;
}
//# sourceMappingURL=connection.d.ts.map
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/node_modules/@nestjs/common/index.d.ts">
import 'reflect-metadata';
export * from './decorators';
export * from './enums';
export * from './exceptions';
export * from './file-stream';
export { Abstract, ArgumentMetadata, ArgumentsHost, BeforeApplicationShutdown, CallHandler, CanActivate, ClassProvider, ContextType, DynamicModule, ExceptionFilter, ExecutionContext, ExistingProvider, FactoryProvider, ForwardReference, HttpServer, HttpExceptionBody, HttpExceptionBodyMessage, HttpRedirectResponse, INestApplication, INestApplicationContext, INestMicroservice, InjectionToken, IntrospectionResult, MessageEvent, MiddlewareConsumer, ModuleMetadata, NestApplicationOptions, NestHybridApplicationOptions, NestInterceptor, NestMiddleware, NestModule, OnApplicationBootstrap, OnApplicationShutdown, OnModuleDestroy, OnModuleInit, OptionalFactoryDependency, Paramtype, PipeTransform, Provider, RawBodyRequest, RpcExceptionFilter, Scope, ScopeOptions, Type, ValidationError, ValueProvider, VersioningOptions, VERSION_NEUTRAL, WebSocketAdapter, WsExceptionFilter, WsMessageHandler, } from './interfaces';
export * from './module-utils';
export * from './pipes';
export * from './serializer';
export * from './services';
export * from './utils';

</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/node_modules/socket.io/dist/index.d.ts">
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import http = require("http");
import type { Server as HTTPSServer } from "https";
import type { Http2SecureServer, Http2Server } from "http2";
import type { ServerOptions as EngineOptions, AttachOptions, BaseServer } from "engine.io";
import { ExtendedError, Namespace, ServerReservedEventsMap } from "./namespace";
import { Adapter, Room, SocketId } from "socket.io-adapter";
import * as parser from "socket.io-parser";
import type { Encoder } from "socket.io-parser";
import { Socket, DisconnectReason } from "./socket";
import type { BroadcastOperator, RemoteSocket } from "./broadcast-operator";
import { EventsMap, DefaultEventsMap, EventParams, StrictEventEmitter, EventNames, DecorateAcknowledgementsWithTimeoutAndMultipleResponses, AllButLast, Last, RemoveAcknowledgements, EventNamesWithAck, FirstNonErrorArg } from "./typed-events";
declare type ParentNspNameMatchFn = (name: string, auth: {
    [key: string]: any;
}, fn: (err: Error | null, success: boolean) => void) => void;
declare type AdapterConstructor = typeof Adapter | ((nsp: Namespace) => Adapter);
declare type TServerInstance = http.Server | HTTPSServer | Http2SecureServer | Http2Server;
interface ServerOptions extends EngineOptions, AttachOptions {
    /**
     * name of the path to capture
     * @default "/socket.io"
     */
    path: string;
    /**
     * whether to serve the client files
     * @default true
     */
    serveClient: boolean;
    /**
     * the adapter to use
     * @default the in-memory adapter (https://github.com/socketio/socket.io-adapter)
     */
    adapter: AdapterConstructor;
    /**
     * the parser to use
     * @default the default parser (https://github.com/socketio/socket.io-parser)
     */
    parser: any;
    /**
     * how many ms before a client without namespace is closed
     * @default 45000
     */
    connectTimeout: number;
    /**
     * Whether to enable the recovery of connection state when a client temporarily disconnects.
     *
     * The connection state includes the missed packets, the rooms the socket was in and the `data` attribute.
     */
    connectionStateRecovery: {
        /**
         * The backup duration of the sessions and the packets.
         *
         * @default 120000 (2 minutes)
         */
        maxDisconnectionDuration?: number;
        /**
         * Whether to skip middlewares upon successful connection state recovery.
         *
         * @default true
         */
        skipMiddlewares?: boolean;
    };
    /**
     * Whether to remove child namespaces that have no sockets connected to them
     * @default false
     */
    cleanupEmptyChildNamespaces: boolean;
}
/**
 * Represents a Socket.IO server.
 *
 * @example
 * import { Server } from "socket.io";
 *
 * const io = new Server();
 *
 * io.on("connection", (socket) => {
 *   console.log(`socket ${socket.id} connected`);
 *
 *   // send an event to the client
 *   socket.emit("foo", "bar");
 *
 *   socket.on("foobar", () => {
 *     // an event was received from the client
 *   });
 *
 *   // upon disconnection
 *   socket.on("disconnect", (reason) => {
 *     console.log(`socket ${socket.id} disconnected due to ${reason}`);
 *   });
 * });
 *
 * io.listen(3000);
 */
export declare class Server<ListenEvents extends EventsMap = DefaultEventsMap, EmitEvents extends EventsMap = ListenEvents, ServerSideEvents extends EventsMap = DefaultEventsMap, SocketData = any> extends StrictEventEmitter<ServerSideEvents, RemoveAcknowledgements<EmitEvents>, ServerReservedEventsMap<ListenEvents, EmitEvents, ServerSideEvents, SocketData>> {
    readonly sockets: Namespace<ListenEvents, EmitEvents, ServerSideEvents, SocketData>;
    /**
     * A reference to the underlying Engine.IO server.
     *
     * @example
     * const clientsCount = io.engine.clientsCount;
     *
     */
    engine: BaseServer;
    /** @private */
    readonly _parser: typeof parser;
    /** @private */
    readonly encoder: Encoder;
    /**
     * @private
     */
    _nsps: Map<string, Namespace<ListenEvents, EmitEvents, ServerSideEvents, SocketData>>;
    private parentNsps;
    /**
     * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular
     * expression.
     *
     * @private
     */
    private parentNamespacesFromRegExp;
    private _adapter?;
    private _serveClient;
    private readonly opts;
    private eio;
    private _path;
    private clientPathRegex;
    /**
     * @private
     */
    _connectTimeout: number;
    private httpServer;
    private _corsMiddleware;
    /**
     * Server constructor.
     *
     * @param srv http server, port, or options
     * @param [opts]
     */
    constructor(opts?: Partial<ServerOptions>);
    constructor(srv?: TServerInstance | number, opts?: Partial<ServerOptions>);
    constructor(srv: undefined | Partial<ServerOptions> | TServerInstance | number, opts?: Partial<ServerOptions>);
    get _opts(): Partial<ServerOptions>;
    /**
     * Sets/gets whether client code is being served.
     *
     * @param v - whether to serve client code
     * @return self when setting or value when getting
     */
    serveClient(v: boolean): this;
    serveClient(): boolean;
    serveClient(v?: boolean): this | boolean;
    /**
     * Executes the middleware for an incoming namespace not already created on the server.
     *
     * @param name - name of incoming namespace
     * @param auth - the auth parameters
     * @param fn - callback
     *
     * @private
     */
    _checkNamespace(name: string, auth: {
        [key: string]: any;
    }, fn: (nsp: Namespace<ListenEvents, EmitEvents, ServerSideEvents, SocketData> | false) => void): void;
    /**
     * Sets the client serving path.
     *
     * @param {String} v pathname
     * @return {Server|String} self when setting or value when getting
     */
    path(v: string): this;
    path(): string;
    path(v?: string): this | string;
    /**
     * Set the delay after which a client without namespace is closed
     * @param v
     */
    connectTimeout(v: number): this;
    connectTimeout(): number;
    connectTimeout(v?: number): this | number;
    /**
     * Sets the adapter for rooms.
     *
     * @param v pathname
     * @return self when setting or value when getting
     */
    adapter(): AdapterConstructor | undefined;
    adapter(v: AdapterConstructor): this;
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     */
    listen(srv: TServerInstance | number, opts?: Partial<ServerOptions>): this;
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     */
    attach(srv: TServerInstance | number, opts?: Partial<ServerOptions>): this;
    attachApp(app: any, opts?: Partial<ServerOptions>): void;
    /**
     * Initialize engine
     *
     * @param srv - the server to attach to
     * @param opts - options passed to engine.io
     * @private
     */
    private initEngine;
    /**
     * Attaches the static file serving.
     *
     * @param srv http server
     * @private
     */
    private attachServe;
    /**
     * Handles a request serving of client source and map
     *
     * @param req
     * @param res
     * @private
     */
    private serve;
    /**
     * @param filename
     * @param req
     * @param res
     * @private
     */
    private static sendFile;
    /**
     * Binds socket.io to an engine.io instance.
     *
     * @param engine engine.io (or compatible) server
     * @return self
     */
    bind(engine: BaseServer): this;
    /**
     * Called with each incoming transport connection.
     *
     * @param {engine.Socket} conn
     * @return self
     * @private
     */
    private onconnection;
    /**
     * Looks up a namespace.
     *
     * @example
     * // with a simple string
     * const myNamespace = io.of("/my-namespace");
     *
     * // with a regex
     * const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
     *   const namespace = socket.nsp; // newNamespace.name === "/dynamic-101"
     *
     *   // broadcast to all clients in the given sub-namespace
     *   namespace.emit("hello");
     * });
     *
     * @param name - nsp name
     * @param fn optional, nsp `connection` ev handler
     */
    of(name: string | RegExp | ParentNspNameMatchFn, fn?: (socket: Socket<ListenEvents, EmitEvents, ServerSideEvents, SocketData>) => void): Namespace<ListenEvents, EmitEvents, ServerSideEvents, SocketData>;
    /**
     * Closes server connection
     *
     * @param [fn] optional, called as `fn([err])` on error OR all conns closed
     */
    close(fn?: (err?: Error) => void): void;
    /**
     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
     *
     * @example
     * io.use((socket, next) => {
     *   // ...
     *   next();
     * });
     *
     * @param fn - the middleware function
     */
    use(fn: (socket: Socket<ListenEvents, EmitEvents, ServerSideEvents, SocketData>, next: (err?: ExtendedError) => void) => void): this;
    /**
     * Targets a room when emitting.
     *
     * @example
     * // the “foo” event will be broadcast to all connected clients in the “room-101” room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * io.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room: Room | Room[]): BroadcastOperator<import("./typed-events").DecorateAcknowledgementsWithMultipleResponses<EmitEvents>, SocketData>;
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * // disconnect all clients in the "room-101" room
     * io.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room: Room | Room[]): BroadcastOperator<import("./typed-events").DecorateAcknowledgementsWithMultipleResponses<EmitEvents>, SocketData>;
    /**
     * Excludes a room when emitting.
     *
     * @example
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * io.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * io.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room: Room | Room[]): BroadcastOperator<import("./typed-events").DecorateAcknowledgementsWithMultipleResponses<EmitEvents>, SocketData>;
    /**
     * Sends a `message` event to all clients.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * io.send("hello");
     *
     * // this is equivalent to
     * io.emit("message", "hello");
     *
     * @return self
     */
    send(...args: EventParams<EmitEvents, "message">): this;
    /**
     * Sends a `message` event to all clients. Alias of {@link send}.
     *
     * @return self
     */
    write(...args: EventParams<EmitEvents, "message">): this;
    /**
     * Sends a message to the other Socket.IO servers of the cluster.
     *
     * @example
     * io.serverSideEmit("hello", "world");
     *
     * io.on("hello", (arg1) => {
     *   console.log(arg1); // prints "world"
     * });
     *
     * // acknowledgements (without binary content) are supported too:
     * io.serverSideEmit("ping", (err, responses) => {
     *  if (err) {
     *     // some servers did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per server (except the current one)
     *   }
     * });
     *
     * io.on("ping", (cb) => {
     *   cb("pong");
     * });
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit<Ev extends EventNames<ServerSideEvents>>(ev: Ev, ...args: EventParams<DecorateAcknowledgementsWithTimeoutAndMultipleResponses<ServerSideEvents>, Ev>): boolean;
    /**
     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
     *
     * @example
     * try {
     *   const responses = await io.serverSideEmitWithAck("ping");
     *   console.log(responses); // one response per server (except the current one)
     * } catch (e) {
     *   // some servers did not acknowledge the event in the given delay
     * }
     *
     * @param ev - the event name
     * @param args - an array of arguments
     *
     * @return a Promise that will be fulfilled when all servers have acknowledged the event
     */
    serverSideEmitWithAck<Ev extends EventNamesWithAck<ServerSideEvents>>(ev: Ev, ...args: AllButLast<EventParams<ServerSideEvents, Ev>>): Promise<FirstNonErrorArg<Last<EventParams<ServerSideEvents, Ev>>>[]>;
    /**
     * Gets a list of socket ids.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
     * {@link Server#fetchSockets} instead.
     */
    allSockets(): Promise<Set<SocketId>>;
    /**
     * Sets the compress flag.
     *
     * @example
     * io.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    compress(compress: boolean): BroadcastOperator<import("./typed-events").DecorateAcknowledgementsWithMultipleResponses<EmitEvents>, SocketData>;
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get volatile(): BroadcastOperator<import("./typed-events").DecorateAcknowledgementsWithMultipleResponses<EmitEvents>, SocketData>;
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * // the “foo” event will be broadcast to all connected clients on this node
     * io.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local(): BroadcastOperator<import("./typed-events").DecorateAcknowledgementsWithMultipleResponses<EmitEvents>, SocketData>;
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout: number): BroadcastOperator<import("./typed-events").DecorateAcknowledgements<import("./typed-events").DecorateAcknowledgementsWithMultipleResponses<EmitEvents>>, SocketData>;
    /**
     * Returns the matching socket instances.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // return all Socket instances
     * const sockets = await io.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await io.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */
    fetchSockets(): Promise<RemoteSocket<EmitEvents, SocketData>[]>;
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     *
     * // make all socket instances join the "room1" room
     * io.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * io.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room: Room | Room[]): void;
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances leave the "room1" room
     * io.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * io.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room: Room | Room[]): void;
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * io.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * io.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close?: boolean): void;
}
export { Socket, DisconnectReason, ServerOptions, Namespace, BroadcastOperator, RemoteSocket, };
export { Event } from "./socket";

</FILE>
<FILE path="src/components/job-state-machine/job-state-machine.handler.ts" TARGET>
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Server } from 'socket.io';
import { CustomLogger } from '../../logger/custom-logger';

import { StateMachineComponent } from '../state-machine/state-machine.handler';

@Injectable()
export class JobStateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  private stateMachine: StateMachineComponent;
  
  public ports = {
    inputs: [
      'any.publish.initializeMachine',
      'any.publish.start',
      'any.publish.pause',
      'any.publish.resume',
      'any.publish.finish',
      'any.publish.reset'
    ],
    outputs: [
      'any.publish.initializeMachine',
      'any.publish.start',
      'any.publish.pause',
      'any.publish.resume',
      'any.publish.finish',
      'any.publish.reset',
      'any.publish.stateChanged',
      'htmx.display.job-state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(AmqpConnection) amqpConnection: AmqpConnection,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
  ) {
    super('jobStateMachine', 'job-state-machine', 'Implements a job state machine', flowId, componentId, amqpConnection, server);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`, this.amqpConnection);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "initializeMachine": {
        await this.initializeMachine(data);
        break;
      }
      case "start":
      case "pause":
      case "resume":
      case "finish":
      case "reset": {
        await this.transition(eventId);
        break;
      }
    }
  }

  private async initializeMachine(data: any): Promise<void> {
    this.getPorts();
    this._ports.inputs.forEach((input) => {
      input.connections.forEach(async (connection) => {
        let smComponent: any = connection.connectedFrom;

        await smComponent.initializeMachine(data);
        await this.updateDisplay(smComponent);

        let currentState = await smComponent.getCurrentState()
        await this.publish(this.flowId, this.componentId, 'initializeMachine', { 
          currentState
        });
      })
    })
  }

  private async transition(event: string): Promise<void> {
    let previousState;
    let currentState;
    this.getPorts();
    this._ports.inputs.forEach((input) => {
      input.connections.forEach(async (connection) => {
        let smComponent: any = connection.connectedFrom;
        previousState = await smComponent.getCurrentState();
        await this.stateMachine.transition({ event });
        currentState = await smComponent.getCurrentState();

        await this.updateDisplay(smComponent);
      })
    });
    

    // Publish to the specific event port
    await this.publish(this.flowId, this.componentId, event, { 
      previousState,
      currentState
    });

    // Also publish to the general stateChanged port
    await this.publish(this.flowId, this.componentId, 'stateChanged', { 
      previousState,
      currentState,
      event
    });
  }

  private async updateDisplay(stateMachineComponent): Promise<void> {
    let currentState = await stateMachineComponent.getCurrentState();
    let states = await stateMachineComponent.getStates();
    let transitions = await stateMachineComponent.getTransitions();

    await this.display(this.flowId, this.componentId, 'job-state-machine', {
      currentState,
      states: Array.from(states),
      transitions: Object.fromEntries(transitions)
    });
  }
}
</FILE>
<REQUEST>
state machine input events should be prefixed with set- and output events should be prefixed with get-
</REQUEST>