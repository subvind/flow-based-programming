# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/flow-based-programming/src/services/backplane.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';
import * as amqp from 'amqplib';
import { MessageQueueClient } from 'message-queue/client';

interface MessageQueueAdapter {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  publish(exchange: string, routingKey: string, message: any): Promise<void>;
  subscribe(exchange: string, routingKey: string, queue: string, callback: (msg: any) => Promise<void>): Promise<void>;
}

class AmqpAdapter implements MessageQueueAdapter {
  private connection: amqp.Connection | null = null;
  private channel: amqp.Channel | null = null;

  constructor(private readonly logger: Logger) {}

  async connect(): Promise<void> {
    this.logger.log('Connecting to RabbitMQ...');
    this.connection = await amqp.connect('amqp://localhost:5672');
    this.channel = await this.connection.createChannel();
    this.logger.log('Successfully connected to RabbitMQ');
  }

  async disconnect(): Promise<void> {
    if (this.channel) {
      await this.channel.close();
      this.channel = null;
    }
    if (this.connection) {
      await this.connection.close();
      this.connection = null;
    }
    this.logger.log('Disconnected from RabbitMQ');
  }

  async publish(exchange: string, routingKey: string, message: any): Promise<void> {
    if (!this.channel) {
      throw new Error('Channel is not available');
    }
    await this.channel.assertExchange(exchange, 'topic', { durable: true });
    this.channel.publish(exchange, routingKey, Buffer.from(JSON.stringify(message)));
  }

  async subscribe(
    exchange: string,
    routingKey: string,
    queue: string,
    callback: (msg: any) => Promise<void>
  ): Promise<void> {
    if (!this.channel) {
      throw new Error('Channel is not available');
    }
    await this.channel.assertExchange(exchange, 'topic', { durable: true });
    const q = await this.channel.assertQueue(queue, { exclusive: false, durable: true });
    await this.channel.bindQueue(q.queue, exchange, routingKey);
    
    this.channel.consume(q.queue, async (msg) => {
      if (msg !== null) {
        const content = JSON.parse(msg.content.toString());
        await callback(content);
        this.channel.ack(msg);
      }
    });
  }
}

class IsmqAdapter implements MessageQueueAdapter {
  private client: MessageQueueClient | null = null;

  constructor(private readonly logger: Logger) {}

  async connect(): Promise<void> {
    this.logger.log('Connecting to ISMQ...');
    this.client = new MessageQueueClient('http://localhost:3030');
    await this.client.connectWebSocket();
    this.logger.log('Successfully connected to ISMQ');
  }

  async disconnect(): Promise<void> {
    if (this.client) {
      this.client.disconnectWebSocket();
      this.client = null;
    }
    this.logger.log('Disconnected from ISMQ');
  }

  async publish(exchange: string, routingKey: string, message: any): Promise<void> {
    if (!this.client) {
      throw new Error('ISMQ is not available');
    }
    this.logger.log(`Publishing message to exchange: ${exchange}, routingKey: ${routingKey}`);
    await this.client.createExchange(exchange);
    await this.client.publish(exchange, routingKey, message);
    this.logger.log('Message published successfully');
  }

  async subscribe(
    exchange: string,
    routingKey: string,
    queue: string,
    callback: (msg: any) => Promise<void>
  ): Promise<void> {
    if (!this.client) {
      throw new Error('ISMQ is not available');
    }
    this.logger.log(`Subscribing to exchange: ${exchange}, routingKey: ${routingKey}, queue: ${queue}`);
    await this.client.createExchange(exchange);
    await this.client.bind(exchange, queue, routingKey);
    await this.client.subscribeToQueue(exchange, queue, async (message) => {
      this.logger.log(`Received message on queue: ${queue}`);
      try {
        await callback(message);
        this.logger.log(`Successfully processed message from queue: ${queue}`);
      } catch (error) {
        this.logger.error(`Error processing message from queue ${queue}: ${error.message}`);
      }
    });
    this.logger.log(`Successfully subscribed to queue: ${queue}`);
  }
}

@Injectable()
export class BackplaneService implements OnModuleInit, OnModuleDestroy {
  private adapter: MessageQueueAdapter;
  private readonly logger = new Logger(BackplaneService.name);
  private isInitialized = false;

  constructor() {
    // You can switch between 'amqp' and 'ismq' here or use an environment variable
    const adapterType = process.env.MESSAGE_QUEUE_ADAPTER || 'ismq';
    this.adapter = adapterType === 'amqp' ? new AmqpAdapter(this.logger) : new IsmqAdapter(this.logger);
  }

  async onModuleInit() {
    await this.connect();
  }

  async onModuleDestroy() {
    await this.disconnect();
  }

  private async connect() {
    try {
      await this.adapter.connect();
      this.isInitialized = true;
    } catch (error) {
      this.logger.error('Failed to connect to message queue', error);
      this.isInitialized = false;
      throw error;
    }
  }

  private async disconnect() {
    try {
      await this.adapter.disconnect();
      this.isInitialized = false;
    } catch (error) {
      this.logger.error('Error disconnecting from message queue', error);
    }
  }

  async publish(exchange: string, routingKey: string, message: any): Promise<void> {
    await this.ensureConnection();
    await this.adapter.publish(exchange, routingKey, message);
  }

  async subscribe(
    exchange: string,
    routingKey: string,
    queue: string,
    callback: (msg: any) => Promise<void>
  ): Promise<void> {
    await this.ensureConnection();
    await this.adapter.subscribe(exchange, routingKey, queue, callback);
  }

  private async ensureConnection(): Promise<void> {
    if (!this.isInitialized) {
      this.logger.warn('Connection not initialized, attempting to reconnect...');
      await this.connect();
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/processors/event.processor.ts">
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ComponentRegistry } from '../services/component-registry.service';
import { BackplaneService } from '../services/backplane.service';

@Injectable()
export class EventProcessor implements OnModuleInit {
  private readonly logger = new Logger(EventProcessor.name);
  private connections: Map<string, Array<{ toFlow: string; toComponent: string; toEvent: string }>> = new Map();

  constructor(
    private componentRegistry: ComponentRegistry,
    private backplaneService: BackplaneService
  ) {}

  async onModuleInit() {
    await this.subscribeToEvents();
  }

  private async subscribeToEvents() {
    try {
      await this.backplaneService.subscribe(
        'flow_exchange',
        'componentEvent',
        'component_event_queue',
        this.handleComponentEvent.bind(this)
      );

      await this.backplaneService.subscribe(
        'flow_exchange',
        'createConnection',
        'create_connection_queue',
        this.createConnection.bind(this)
      );
    } catch (error) {
      this.logger.error(`Failed to subscribe to events: ${error.message}`, error.stack);
    }
  }

  async handleComponentEvent(msg: {flowId: string, componentId: string, eventId: string, data: any}): Promise<void> {
    const { flowId, componentId, eventId, data: eventData } = msg;
    this.logger.log(`[handleComponentEvent] [${flowId}.${componentId}.${eventId}] data: ${JSON.stringify(eventData)}`);
    
    const component = this.componentRegistry.getComponent(flowId, componentId);
    if (component) {
      this.logger.log(`Passing event to component: ${componentId}`);
      await component.handleEvent(eventId, eventData);

      // Check if there are connections for this event
      const connectionKey = `${flowId}.${componentId}.${eventId}`;
      const connections = this.connections.get(connectionKey) || [];
      for (const connection of connections) {
        const { toFlow, toComponent, toEvent } = connection;
        this.logger.log(`[forwardingComponentEvent] [${toFlow}.${toComponent}.${toEvent}]`);
        
        const targetComponent = this.componentRegistry.getComponent(toFlow, toComponent);
        if (targetComponent) {
          this.logger.log(`Forwarding event to component: ${targetComponent.componentId}`);
          await targetComponent.handleEvent(toEvent, eventData);
        } else {
          this.logger.warn(`Target component not found: ${toComponent} in flow: ${toFlow}`);
        }
      }
    } else {
      this.logger.warn(`Component not found: ${flowId}.${componentId}`);
    }
  }

  async createConnection(msg: {flowId: string, fromComponent: string, fromEvent: string, toComponent: string, toEvent: string}): Promise<void>  {
    const { flowId, fromComponent, fromEvent, toComponent, toEvent } = msg;
    this.logger.log(`Received createConnection: ${flowId}.${fromComponent}.${fromEvent} -> ${toComponent}.${toEvent}`);
    
    const connectionKey = `${flowId}.${fromComponent}.${fromEvent}`;
    if (!this.connections.has(connectionKey)) {
      this.connections.set(connectionKey, []);
    }
    this.connections.get(connectionKey).push({ toFlow: flowId, toComponent, toEvent });
    this.logger.log(`Connection created: ${connectionKey} -> ${toComponent}.${toEvent}`);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/logger/custom-logger.ts">
import { ConsoleLogger, Injectable, Inject } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class CustomLogger extends ConsoleLogger {
  constructor(
    private logId: string,
  ) {
    super(logId);
    this.setLogLevels(['log', 'error', 'warn', 'debug', 'verbose']);
  }

  log(message: string, context?: string) {
    this.printMessage(message, 'log', context);
    // this.emitLogEvent('log', message);
  }

  warn(message: string, context?: string) {
    this.printMessage(message, 'warn', context);
    // this.emitLogEvent('warn', message);
  }

  error(message: string, trace?: string, context?: string) {
    this.printMessage(message, 'error', context);
    // this.emitLogEvent('error', message);
    if (trace) {
      this.printMessage(trace, 'error', context);
    }
  }

  debug(message: string, context?: string) {
    this.printMessage(message, 'debug', context);
  }

  verbose(message: string, context?: string) {
    this.printMessage(message, 'verbose', context);
  }

  private printMessage(message: string, logLevel: string, context?: string) {
    const output = context ? `[${context}] ${message}` : message;
    console.log(`[${this.getNow()}] [${logLevel.toUpperCase()}] [${this.logId}] ${output}`);
  }

  private getNow(): string {
    return new Date().toISOString();
  }

  static write_to_file(message: string) {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    fs.appendFile(logFile, message, (err) => {
      if (err) {
        console.error('Failed to write to log file:', err);
      }
    });
  }

  static clearSTDOUT() {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    try {
      fs.writeFileSync(logFile, '');
      console.log(`Log file cleared at ${logFile}`);
    } catch (error) {
      console.error('Failed to clear log file:', error);
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/bootstrap/app.bootstrap.ts">
import { NestFactory } from '@nestjs/core';
import { AppModule } from '../modules/app.module';
import { NestExpressApplication } from '@nestjs/platform-express';
import * as cookieParser from 'cookie-parser';
import { FlowExecutorService } from '../services/flow-executor.service';
import { CustomLogger } from '../logger/custom-logger';
import { resolve } from 'path';
import { initializeFlows } from '../initializers/flows.initialize';

export async function bootstrapApp(logger: CustomLogger): Promise<any> {
  const app = await NestFactory.create<NestExpressApplication>(AppModule, { logger });
  
  app.useStaticAssets(resolve('./src/public'));
  app.setBaseViewsDir(resolve('./src/views'));
  app.setViewEngine('ejs');

  app.use(cookieParser());

  // so browsers can use api
  app.enableCors({
    origin: '*',
  });

  const flowExecutor = app.get(FlowExecutorService);

  await app.init();

  logger.log('Starting flow execution...');
  await initializeFlows(flowExecutor);

  await app.listen(3000);
  logger.log('Application is running on: http://localhost:3000');

  return app;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/main.ts">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './modules/app.module';
import { CustomLogger } from './logger/custom-logger';
import { bootstrapApp } from './bootstrap/app.bootstrap';
import { EventEmitter } from 'events';

async function bootstrap(): Promise<void> {
  // Increase the maximum number of listeners
  EventEmitter.defaultMaxListeners = 100;

  const app = await NestFactory.create(AppModule);
  
  // Create the CustomLogger
  const logger = new CustomLogger('Bootstrap');
  
  try {
    logger.log('Starting main application...');
    const mainApp = await bootstrapApp(logger);

    process.on('SIGINT', async () => {
      CustomLogger.clearSTDOUT();
      await mainApp.close();
      process.exit();
    });
  } catch (error) {
    logger.error(`Bootstrap error: ${error.message}`, error.stack);
    process.exit(1);
  }
}

bootstrap().catch((error) => {
  console.error('Unhandled bootstrap error:', error);
  process.exit(1);
});
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/modules/app.module.ts">
import { ComponentRegistry } from '../services/component-registry.service';
import { FlowExecutorService } from '../services/flow-executor.service';
import { EventProcessor } from '../processors/event.processor';
import { CustomLogger } from '../logger/custom-logger';
import { AppController } from '../controllers/app.controller';
import { TemplateCacheService } from 'src/services/template-cache.service';
import { BackplaneService } from '../services/backplane.service';

import { initializeAppModule, components } from '../initializers/app.initialize';

const rabbitmqUri = process.env.RABBITMQ || 'amqp://localhost:5672';
console.log(`[AppModule] RabbitMQ URI: ${rabbitmqUri}`);

const metadata = {
  imports: [],
  controllers: [AppController],
  providers: [
    EventProcessor,
    ComponentRegistry,
    FlowExecutorService,
    TemplateCacheService,
    BackplaneService,
    {
      provide: 'BACKPLANE',
      useFactory: (backplaneService: BackplaneService) => {
        return () => backplaneService.onModuleInit();
      },
      inject: [BackplaneService],
      multi: true,
    },
    {
      provide: 'FLOW_ID',
      useValue: 'example-flow', // Use a default flow ID
    },
    {
      provide: 'COMPONENT_ID',
      useFactory: () => `component-${Date.now()}`, // Generate a unique component ID
    },
    {
      provide: 'WEB_SOCKET_SERVER',
      useValue: null, // This will be set later in the FlowExecutorService
    },
    {
      provide: 'TEMPLATES',
      useValue: null, // This will be set later (?)
    },
    ...components,
    CustomLogger
  ],
  exports: [EventProcessor],
}

export const AppModule = initializeAppModule(metadata)
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/button-trigger/button-trigger.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

import { triggerButton } from './trigger-button.event';
import { init } from './init.event';

@Injectable()
export class ButtonTriggerComponent extends ComponentBase {
  public template: string = 'button-trigger';
  public logger: CustomLogger;
  public ports = {
    inputs: [
      'any.publish.triggerButton',
      'any.publish.init',
    ],
    outputs: [
      'any.publish.buttonPressed',
      'htmx.display.button-trigger'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('buttonTrigger', 'button-trigger', 'Handles button presses and triggers events', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "init": {
        await this.init(data);
        break;
      }
      case "triggerButton": {
        await this.triggerButton(data);
        break;
      }
      default: {
        break;
      }
    }
  }

  private async init(data: any): Promise<void> {
    return init(this, data);
  }

  private async triggerButton(data: any): Promise<void> {
    return triggerButton(this, data);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/event-trigger/event-trigger.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

import { triggerEvent } from './trigger-event.event';

@Injectable()
export class EventTriggerComponent extends ComponentBase {
  public logger: CustomLogger;
  public ports = { // io format: <dataType>.<dataMethod>.<eventId>
    inputs: [
      'any.publish.triggerEvent',
    ],
    outputs: [
      'any.publish.any'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) protected backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('eventTrigger', 'event-trigger', 'Handles HTMX requests and triggers events', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    switch (eventId) {
      case 'triggerEvent':
        await this.triggerEvent(data);
        break;
      default:
        break;
    }
  }

  private async triggerEvent(data: any): Promise<void> {
    return await triggerEvent(this, data);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/job-state-machine/job-state-machine.handler.ts">
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { CustomLogger } from '../../logger/custom-logger';
import { TemplateCacheService } from 'src/services/template-cache.service';

import { StateMachine } from 'src/interfaces/state-machine.interface';
import { initProxyMachine } from 'src/events/initProxyMachine.event';
import { transition } from 'src/events/transition.event';

@Injectable()
export class JobStateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  public stateMachine: StateMachine;
  
  public ports = {
    inputs: [
      'any.publish.initProxyMachine',
      'any.publish.set-start',
      'any.publish.set-pause',
      'any.publish.set-resume',
      'any.publish.set-finish',
      'any.publish.set-reset'
    ],
    outputs: [
      'any.publish.get-start',
      'any.publish.get-pause',
      'any.publish.get-resume',
      'any.publish.get-finish',
      'any.publish.get-reset',
      'any.publish.stateChanged',
      'htmx.display.job-state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('jobStateMachine', 'job-state-machine', 'Implements a job state machine', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "initProxyMachine": {
        await this.initProxyMachine(data);
        break;
      }
      case "set-start":
      case "set-pause":
      case "set-resume":
      case "set-finish":
      case "set-reset": {
        await this.transition(eventId.substring(4)); // Remove 'set-' prefix
        break;
      }
    }
  }

  public initProxyMachine(data): Promise<void> {
    return initProxyMachine(this, data);
  }

  public transition(data): Promise<void> {
    return transition(this, data);
  }

  public async updateDisplay(): Promise<void> {
    if (!this.stateMachine) {
      this.logger.error('[display] State machine not initialized');
      return;
    }

    const currentState = this.stateMachine.getCurrentState();
    const states = this.stateMachine.getStates();
    const transitions = this.stateMachine.getTransitions();

    await this.display(this.flowId, this.componentId, 'job-state-machine', {
      currentState,
      states: Array.from(states),
      transitions: Object.fromEntries(transitions)
    });
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/number-generator/number-generator.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

import { startGenerating } from './start-generating.event';
import { stopGenerating } from './stop-generating.event';

@Injectable()
export class NumberGeneratorComponent extends ComponentBase {
  public logger;
  public interval: NodeJS.Timeout | null = null;
  public ports = { // io format: <dataType>.<dataMethod>.<eventId>
    inputs: [
      'any.publish.start',
      'any.publish.stop'
    ],
    outputs: [
      'number.publish.numberGenerated',
      'htmx.display.number-generator'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('numberGenerator', 'number-generator', 'Generates random numbers periodically', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`NumberGenerator (${this.flowId}) handling event: ${eventId}`);
    switch (eventId) {
      case "start": {
        this.logger.log(`NumberGenerator (${this.flowId}) starting number generation`);
        this.startGenerating(data);
        break;
      }
      case "stop": {
        this.logger.log(`NumberGenerator (${this.flowId}) stopping number generation`);
        this.stopGenerating(data);
        break;
      }
    }
  }

  private startGenerating(data): void {
    return startGenerating(this, data);
  }

  private stopGenerating(data): void {
    return stopGenerating(this, data);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/number-multiplier/number-multiplier.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

import { numberReceived } from './number-received.event';

@Injectable()
export class NumberMultiplierComponent extends ComponentBase {
  public logger;
  public ports = { // io format: <dataType>.<dataMethod>.<eventId>
    inputs: [
      'number.publish.firstNumberReceived',
      'number.publish.secondNumberReceived',
    ],
    outputs: [
      'number.publish.numberMultiplied',
      'htmx.display.number-multiplier',
    ]
  }

  public firstNumber: number | null = null;
  public secondNumber: number | null = null;

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('numberMultiplier', 'number-multiplier', 'Multiplies two received numbers', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`NumberMultiplier handling event: ${eventId} ${JSON.stringify(data, null, 2)}`);
    switch (eventId) {
      case 'firstNumberReceived':
        await this.numberReceived(data, 'first');
        break;
      case 'secondNumberReceived':
        await this.numberReceived(data, 'second');
        break;
      default:
        break;
    }
  }

  private numberReceived(data: any, which: 'first' | 'second'): Promise<void> {
    return numberReceived(this, data, which);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/state-machine/state-machine.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

import { init } from './init.event';
import { initStateMachine } from './initStateMachine.event';
import { transition } from './transition.event';

@Injectable()
export class StateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  public currentState: string;
  public states: Set<string>;
  public transitions: Map<string, Map<string, string>>;
  
  public ports = {
    inputs: [
      'any.publish.initStateMachine',
      'any.publish.transition'
    ],
    outputs: [
      'any.publish.initProxyMachine',
      'any.publish.stateChanged',
      'htmx.display.state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('stateMachine', 'state-machine', 'Implements a simple state machine', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
    this.states = new Set();
    this.transitions = new Map();
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "init": {
        await this.init(data);
        break;
      }
      case "initStateMachine": {
        await this.initStateMachine(data);
        break;
      }
      case "transition": {
        await this.transition(data);
        break;
      }
      default: {
        this.logger.warn(`Unknown event: ${eventId}`);
      }
    }
  }

  public async init(data: any): Promise<void> {
    return init(this, data);
  }

  public async initStateMachine(data: any): Promise<void> {
    return initStateMachine(this, data);
  }

  public async transition(data: any): Promise<void> {
    return transition(this, data);
  }

  public getCurrentState(): string {
    return this.currentState;
  }

  public getStates(): Set<string> {
    return this.states;
  }

  public getTransitions(): Map<string, Map<string, string>> {
    return this.transitions;
  }
}
</FILE>
<FILE path="start:dev.stdout.txt" TARGET>
c[[90m1:14:54 PM[0m] Starting compilation in watch mode...

[[90m1:14:55 PM[0m] Found 0 errors. Watching for file changes.

[AppModule] RabbitMQ URI: amqp://localhost:5672
[32m[Nest] 2116188  - [39m09/10/2024, 1:14:55 PM [32m    LOG[39m [38;5;3m[NestFactory] [39m[32mStarting Nest application...[39m
[32m[Nest] 2116188  - [39m09/10/2024, 1:14:55 PM [32m    LOG[39m [38;5;3m[InstanceLoader] [39m[32mAppModule dependencies initialized[39m[38;5;3m +9ms[39m
[2024-09-10T18:14:55.760Z] [LOG] [Bootstrap] Starting main application...
[2024-09-10T18:14:55.760Z] [LOG] [Bootstrap] [NestFactory] Starting Nest application...
[2024-09-10T18:14:55.762Z] [LOG] [Bootstrap] [InstanceLoader] AppModule dependencies initialized
[2024-09-10T18:14:55.769Z] [LOG] [Bootstrap] [WebSocketsController] EventTriggerComponent subscribed to the "client-event" message
[2024-09-10T18:14:55.770Z] [LOG] [Bootstrap] [WebSocketsController] NumberGeneratorComponent subscribed to the "client-event" message
[2024-09-10T18:14:55.770Z] [LOG] [Bootstrap] [WebSocketsController] NumberMultiplierComponent subscribed to the "client-event" message
[2024-09-10T18:14:55.771Z] [LOG] [Bootstrap] [WebSocketsController] StateMachineComponent subscribed to the "client-event" message
[2024-09-10T18:14:55.771Z] [LOG] [Bootstrap] [WebSocketsController] JobStateMachineComponent subscribed to the "client-event" message
[2024-09-10T18:14:55.771Z] [LOG] [Bootstrap] [WebSocketsController] ButtonTriggerComponent subscribed to the "client-event" message
[2024-09-10T18:14:55.773Z] [LOG] [Bootstrap] [RoutesResolver] AppController {/}:
[2024-09-10T18:14:55.774Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/, GET} route
[2024-09-10T18:14:55.774Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/flows, GET} route
[2024-09-10T18:14:55.774Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/flow/:flowId, GET} route
[2024-09-10T18:14:55.775Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/document/:flowId/:componentId, GET} route
[2024-09-10T18:14:55.775Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/documentComponent/:flowId/:componentId/:swimlaneId, GET} route
[2024-09-10T18:14:55.775Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/documentConnections/:flowId/:componentId/:portId/:swimlaneId, GET} route
[2024-09-10T18:14:55.775Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/logger, GET} route
[2024-09-10T18:14:55.775Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/trigger-event/:flowComponentEvent, POST} route
[2024-09-10T18:14:55.775Z] [LOG] [Bootstrap] [RouterExplorer] Mapped {/template/:flowId/:componentId/:templateId, GET} route
[2024-09-10T18:14:55.776Z] [WARN] [Bootstrap] [BackplaneService] Connection not initialized, attempting to reconnect...
[2024-09-10T18:14:55.776Z] [LOG] [Bootstrap] [BackplaneService] Connecting to ISMQ...
[2024-09-10T18:14:55.787Z] [LOG] [Bootstrap] [BackplaneService] Connecting to ISMQ...
Connected to WebSocket server
[2024-09-10T18:14:55.806Z] [LOG] [Bootstrap] [BackplaneService] Successfully connected to ISMQ
[2024-09-10T18:14:55.806Z] [LOG] [Bootstrap] [BackplaneService] Subscribing to exchange: flow_exchange, routingKey: componentEvent, queue: component_event_queue
Connected to WebSocket server
[2024-09-10T18:14:55.812Z] [LOG] [Bootstrap] [BackplaneService] Successfully connected to ISMQ
Subscription response for flow_exchange/component_event_queue: { status: 'ok', message: 'Subscribed successfully' }
[2024-09-10T18:14:55.819Z] [LOG] [Bootstrap] [BackplaneService] Successfully subscribed to queue: component_event_queue
[2024-09-10T18:14:55.819Z] [LOG] [Bootstrap] [BackplaneService] Subscribing to exchange: flow_exchange, routingKey: createConnection, queue: create_connection_queue
Subscription response for flow_exchange/create_connection_queue: { status: 'ok', message: 'Subscribed successfully' }
[2024-09-10T18:14:55.824Z] [LOG] [Bootstrap] [BackplaneService] Successfully subscribed to queue: create_connection_queue
[2024-09-10T18:14:55.824Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.component-1725992095762
[2024-09-10T18:14:55.824Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.component-1725992095762
[2024-09-10T18:14:55.824Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.component-1725992095762
[2024-09-10T18:14:55.824Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.component-1725992095762
[2024-09-10T18:14:55.824Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.component-1725992095762
[2024-09-10T18:14:55.824Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.component-1725992095762
[2024-09-10T18:14:55.825Z] [LOG] [Bootstrap] [NestApplication] Nest application successfully started
[2024-09-10T18:14:55.825Z] [LOG] [Bootstrap] Starting flow execution...
[2024-09-10T18:14:55.825Z] [LOG] [Bootstrap] [FlowExecutorService] Executing flow: example-flow
[2024-09-10T18:14:55.825Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: sm1.initProxyMachine -> jsm1.initProxyMachine
[2024-09-10T18:14:55.825Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.827Z] [LOG] [Bootstrap] Application is running on: http://localhost:3000
[2024-09-10T18:14:55.832Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.832Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: jsm1.get-start -> gen1.start
[2024-09-10T18:14:55.832Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.835Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.835Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: jsm1.get-finish -> gen1.stop
[2024-09-10T18:14:55.835Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.839Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.839Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: jsm1.get-start -> gen2.start
[2024-09-10T18:14:55.839Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.842Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.842Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: jsm1.get-finish -> gen2.stop
[2024-09-10T18:14:55.842Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.844Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.844Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: gen1.numberGenerated -> multi.firstNumberReceived
[2024-09-10T18:14:55.844Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.846Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.846Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: gen2.numberGenerated -> multi.secondNumberReceived
[2024-09-10T18:14:55.846Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.848Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.848Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: btn1.buttonPressed -> jsm1.set-start
[2024-09-10T18:14:55.848Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.851Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.851Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: btn2.buttonPressed -> jsm1.set-pause
[2024-09-10T18:14:55.851Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.854Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.854Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: btn3.buttonPressed -> jsm1.set-resume
[2024-09-10T18:14:55.854Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.856Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.856Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: btn4.buttonPressed -> jsm1.set-finish
[2024-09-10T18:14:55.856Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.858Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.858Z] [LOG] [Bootstrap] [FlowExecutorService] Creating connection: btn5.buttonPressed -> jsm1.set-reset
[2024-09-10T18:14:55.858Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: createConnection
[2024-09-10T18:14:55.859Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.859Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: main (eventTrigger) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.main
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: btn1 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.btn1
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: btn2 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.btn2
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: btn3 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.btn3
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: btn4 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.btn4
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: btn5 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.btn5
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: sm1 (stateMachine) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.sm1
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: jsm1 (jobStateMachine) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.jsm1
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: gen1 (numberGenerator) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.gen1
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: gen2 (numberGenerator) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.gen2
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Constructing component: multi (numberMultiplier) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [ComponentRegistry] Registering component: example-flow.multi
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: main (main) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: btn1 (btn1) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: btn2 (btn2) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: btn3 (btn3) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: btn4 (btn4) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: btn5 (btn5) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: sm1 (sm1) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: jsm1 (jsm1) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: gen1 (gen1) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: gen2 (gen2) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Sync connections for component: multi (multi) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: main (eventTrigger) for flow: example-flow
[2024-09-10T18:14:55.860Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.862Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.862Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: btn1 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.862Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.864Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.864Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: btn2 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.864Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.867Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.867Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: btn3 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.867Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.868Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.868Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: btn4 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.868Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.871Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.871Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: btn5 (buttonTrigger) for flow: example-flow
[2024-09-10T18:14:55.871Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.874Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.874Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: sm1 (stateMachine) for flow: example-flow
[2024-09-10T18:14:55.874Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.876Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.876Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: jsm1 (jobStateMachine) for flow: example-flow
[2024-09-10T18:14:55.876Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.877Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.877Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: gen1 (numberGenerator) for flow: example-flow
[2024-09-10T18:14:55.877Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.879Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.879Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: gen2 (numberGenerator) for flow: example-flow
[2024-09-10T18:14:55.879Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.881Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully
[2024-09-10T18:14:55.881Z] [LOG] [Bootstrap] [FlowExecutorService] Initializing component: multi (numberMultiplier) for flow: example-flow
[2024-09-10T18:14:55.881Z] [LOG] [Bootstrap] [BackplaneService] Publishing message to exchange: flow_exchange, routingKey: componentEvent
[2024-09-10T18:14:55.882Z] [LOG] [Bootstrap] [BackplaneService] Message published successfully

</FILE>
<REQUEST>
Received message on queue never logged to console is there an error?
</REQUEST>