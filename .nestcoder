# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/flow-based-programming/src/schema/flow.schema.ts">
import { Flow } from "../interfaces/flow.interface";

export function schema(flow: any): Flow {
  const components = Object.entries(flow.components).map(([componentId, component]) => {
    const [componentRef] = Object.keys(component);
    let init;
    let ports = { inputs: [], outputs: [] };

    if (component[componentRef].init) {
      init = component[componentRef].init;
    }

    if (component[componentRef].ports) {
      if (component[componentRef].ports.inputs) {
        ports.inputs = Object.keys(component[componentRef].ports.inputs);
      }
      if (component[componentRef].ports.outputs) {
        ports.outputs = Object.keys(component[componentRef].ports.outputs);
      }
    }

    return { componentId, componentRef, init, ports };
  });

  const connections = flow.connections.map((connection) => {
    const fromParts = connection.from.split('.');
    const toParts = connection.to.split('.');

    // parts format: components.<componentId>.<componentRef>.ports.inputs.<eventId>
    
    return {
      fromFlow: flow.id,
      fromComponent: fromParts[1],
      fromEvent: fromParts[5],
      toFlow: flow.id,
      toComponent: toParts[1],
      toEvent: toParts[5],
    };
  });

  let code = {
    id: flow.id,
    components,
    connections,
  };

  // console.log('code', code);

  return code;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/stateMachines/job.state-machine.ts">
export default {
  initialState: 'idle',
  states: ['idle', 'running', 'paused', 'finished'],
  transitions: {
    idle: { start: 'running' },
    running: { pause: 'paused', finish: 'finished' },
    paused: { resume: 'running', finish: 'finished' },
    finished: { reset: 'idle' }
  }
}

</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/message-generator/message-generator.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

@Injectable()
export class MessageGeneratorComponent extends ComponentBase {
  public logger;
  public interval: NodeJS.Timeout | null = null;
  public ports = {
    inputs: [
      'any.publish.start',
      'any.publish.stop'
    ],
    outputs: [
      'any.publish.messageGenerated'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('messageGenerator', 'message-generator', 'Generates messages for benchmarking', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`MessageGenerator (${this.flowId}) handling event: ${eventId}`);
    switch (eventId) {
      case "start": {
        this.startGenerating();
        break;
      }
      case "stop": {
        this.stopGenerating();
        break;
      }
    }
  }

  private startGenerating(): void {
    this.logger.log(`MessageGenerator (${this.flowId}) starting message generation`);
    if (this.interval) {
      clearInterval(this.interval);
    }
    this.interval = setInterval(async () => {
      const message = { timestamp: Date.now(), content: "Benchmark message" };
      await this.publish(this.flowId, this.componentId, 'messageGenerated', message);
    }, 10); // Generate a message every 10ms
  }

  private stopGenerating(): void {
    this.logger.log(`MessageGenerator (${this.flowId}) stopping message generation`);
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/message-processor/message-processor.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

@Injectable()
export class MessageProcessorComponent extends ComponentBase {
  public logger;
  public ports = {
    inputs: [
      'any.publish.messageReceived'
    ],
    outputs: [
      'any.publish.processingComplete'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('messageProcessor', 'message-processor', 'Processes messages for benchmarking', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`MessageProcessor (${this.flowId}) handling event: ${eventId}`);
    switch (eventId) {
      case "messageReceived": {
        await this.processMessage(data);
        break;
      }
    }
  }

  private async processMessage(message: any): Promise<void> {
    const processingTime = Date.now() - message.timestamp;
    await this.publish(this.flowId, this.componentId, 'processingComplete', { processingTime });
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/benchmark-analyzer/benchmark-analyzer.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

@Injectable()
export class BenchmarkAnalyzerComponent extends ComponentBase {
  public logger;
  private startTime: number | null = null;
  private endTime: number | null = null;
  private dataPoints: number[] = [];
  public ports = {
    inputs: [
      'any.publish.startBenchmark',
      'any.publish.endBenchmark',
      'any.publish.dataPoint'
    ],
    outputs: [
      'any.publish.benchmarkResult'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('benchmarkAnalyzer', 'benchmark-analyzer', 'Analyzes benchmark results', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`BenchmarkAnalyzer (${this.flowId}) handling event: ${eventId}`);
    switch (eventId) {
      case "startBenchmark": {
        this.startBenchmark();
        break;
      }
      case "endBenchmark": {
        await this.endBenchmark();
        break;
      }
      case "dataPoint": {
        this.addDataPoint(data.processingTime);
        break;
      }
    }
  }

  private startBenchmark(): void {
    this.startTime = Date.now();
    this.dataPoints = [];
    this.logger.log(`Benchmark started at ${this.startTime}`);
  }

  private async endBenchmark(): Promise<void> {
    this.endTime = Date.now();
    this.logger.log(`Benchmark ended at ${this.endTime}`);
    const result = this.analyzeBenchmark();
    await this.publish(this.flowId, this.componentId, 'benchmarkResult', result);
  }

  private addDataPoint(processingTime: number): void {
    this.dataPoints.push(processingTime);
  }

  private analyzeBenchmark(): any {
    const totalDuration = this.endTime! - this.startTime!;
    const messageCount = this.dataPoints.length;
    const averageProcessingTime = this.dataPoints.reduce((sum, time) => sum + time, 0) / messageCount;
    const messagesPerSecond = (messageCount / totalDuration) * 1000;

    return {
      totalDuration,
      messageCount,
      averageProcessingTime,
      messagesPerSecond
    };
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/job-state-machine/job-state-machine.handler.ts">
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { CustomLogger } from '../../logger/custom-logger';
import { TemplateCacheService } from 'src/services/template-cache.service';

import { StateMachine } from 'src/interfaces/state-machine.interface';
import { initProxyMachine } from 'src/events/initProxyMachine.event';
import { transition } from 'src/events/transition.event';

@Injectable()
export class JobStateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  public stateMachine: StateMachine;
  
  public ports = {
    inputs: [
      'any.publish.initProxyMachine',
      'any.publish.set-start',
      'any.publish.set-pause',
      'any.publish.set-resume',
      'any.publish.set-finish',
      'any.publish.set-reset'
    ],
    outputs: [
      'any.publish.get-start',
      'any.publish.get-pause',
      'any.publish.get-resume',
      'any.publish.get-finish',
      'any.publish.get-reset',
      'any.publish.stateChanged',
      'htmx.display.job-state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('jobStateMachine', 'job-state-machine', 'Implements a job state machine', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "initProxyMachine": {
        await this.initProxyMachine(data);
        break;
      }
      case "set-start":
      case "set-pause":
      case "set-resume":
      case "set-finish":
      case "set-reset": {
        await this.transition(eventId.substring(4)); // Remove 'set-' prefix
        break;
      }
    }
  }

  public initProxyMachine(data): Promise<void> {
    return initProxyMachine(this, data);
  }

  public transition(data): Promise<void> {
    return transition(this, data);
  }

  public async updateDisplay(): Promise<void> {
    if (!this.stateMachine) {
      this.logger.error('[display] State machine not initialized');
      return;
    }

    const currentState = this.stateMachine.getCurrentState();
    const states = this.stateMachine.getStates();
    const transitions = this.stateMachine.getTransitions();

    await this.display(this.flowId, this.componentId, 'job-state-machine', {
      currentState,
      states: Array.from(states),
      transitions: Object.fromEntries(transitions)
    });
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/state-machine/state-machine.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

import { init } from './init.event';
import { initStateMachine } from './initStateMachine.event';
import { transition } from './transition.event';

@Injectable()
export class StateMachineComponent extends ComponentBase {
  public logger: CustomLogger;
  public currentState: string;
  public states: Set<string>;
  public transitions: Map<string, Map<string, string>>;
  
  public ports = {
    inputs: [
      'any.publish.initStateMachine',
      'any.publish.transition'
    ],
    outputs: [
      'any.publish.initProxyMachine',
      'any.publish.stateChanged',
      'htmx.display.state-machine'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('stateMachine', 'state-machine', 'Implements a simple state machine', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
    this.states = new Set();
    this.transitions = new Map();
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    this.logger.log(`Handling event: ${eventId}`);
    switch (eventId) {
      case "init": {
        await this.init(data);
        break;
      }
      case "initStateMachine": {
        await this.initStateMachine(data);
        break;
      }
      case "transition": {
        await this.transition(data);
        break;
      }
      default: {
        this.logger.warn(`Unknown event: ${eventId}`);
      }
    }
  }

  public async init(data: any): Promise<void> {
    return init(this, data);
  }

  public async initStateMachine(data: any): Promise<void> {
    return initStateMachine(this, data);
  }

  public async transition(data: any): Promise<void> {
    return transition(this, data);
  }

  public getCurrentState(): string {
    return this.currentState;
  }

  public getStates(): Set<string> {
    return this.states;
  }

  public getTransitions(): Map<string, Map<string, string>> {
    return this.transitions;
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/events/initProxyMachine.event.ts">
import { StateMachine } from "src/interfaces/state-machine.interface";

// networks of black box processes, which exchange data
// across predefined connections by message passing
export async function initProxyMachine(process, message): Promise<void> {
  await process.getPorts();
  for (const input of process._ports.inputs) {
    // console.log('input', input)
    for (const connection of input.connections) {
      // console.log('connection', connection)
      const smComponent = connection.connectedFrom as StateMachine;
      if (smComponent) {
        // console.log('smComponent', smComponent)
        process.stateMachine = smComponent;
        // console.log(process.stateMachine.componentId);
        break; // We only need to initialize one state machine
      }
    }
    if (process.stateMachine) break; // Exit if we've found and initialized a state machine
  }
  if (!process.stateMachine) {
    process.logger.error('No valid state machine component found');
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/events/transition.event.ts">
// networks of black box processes, which exchange data
// across predefined connections by message passing
export async function transition(process, message): Promise<void> {
  // console.log('process', process.stateMachine)
  if (!process.stateMachine) {
    process.logger.error('[transition] State machine not initialized');
    return;
  }

  const previousState = process.stateMachine.getCurrentState();
  await process.stateMachine.transition({ event: message });
  const currentState = process.stateMachine.getCurrentState();

  await process.updateDisplay();
  
  if (previousState !== currentState) {
    // Publish to the specific event port
    await process.publish(process.flowId, process.componentId, `get-${message}`, { 
      previousState,
      currentState
    });
  
    // Also publish to the general stateChanged port
    await process.publish(process.flowId, process.componentId, 'stateChanged', { 
      previousState,
      currentState,
      message
    });
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/component.interface.ts">
import { Connection } from "./connection.interface";
import { Port } from "./port.interface";

export interface Component {
  ports: { inputs: string[]; outputs: string[]; };
  componentRef: string;
  slug: string;
  description?: string;
  flowId: string;
  componentId: string;
  handleEvent: (eventId: string, data: any) => Promise<void>;
  publish: (flowId: string, componentId: string, eventId: string, data: any) => Promise<void>;
  getPorts: () => Promise<{ inputs: Port[], outputs: Port[] }>;
  findPort: (portId: string) => Promise<Port>;
  findConnections: (port: Port) => Promise<Connection[]>
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/flow.interface.ts">
import { Connection } from "./connection.interface";

export interface Flow {
  id: string;
  components: {
    componentId: string;
    componentRef: string;
    init: any | undefined;
  }[];
  connections: Connection[];
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/state-machine.interface.ts">
import { Component } from "./component.interface";

export interface StateMachine extends Component {
  transition: (data: any) => Promise<void>;
  initStateMachine: (data: any) => Promise<void>;
  getCurrentState: () => string;
  getStates: () => Set<string>;
  getTransitions: () => Map<string, Map<string, string>>;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/services/flow-executor.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { ComponentRegistry } from './component-registry.service';
import { Flow } from '../interfaces/flow.interface';
import { WebSocketGateway, WebSocketServer } from '@nestjs/websockets';
import { Server } from 'socket.io';
import { initializeComponent } from '../initializers/component.initialize';
import { Component } from 'src/interfaces/component.interface';
import { TemplateCacheService } from './template-cache.service';
import { BackplaneService } from './backplane.service';

@WebSocketGateway()
@Injectable()
export class FlowExecutorService {
  @WebSocketServer() server: Server;
  private readonly logger = new Logger(FlowExecutorService.name);
  private flows: Flow[] = [];
  
  constructor(
    private backplaneService: BackplaneService,
    private componentRegistry: ComponentRegistry,
    private templateCacheService: TemplateCacheService
  ) {}

  async getFlows(): Promise<Flow[]> {
    return this.flows;
  }

  async getFlow(flowId: string): Promise<Flow | undefined> {
    return this.flows.find(flow => flow.id === flowId);
  }

  async executeFlow(flow: Flow) {
    this.logger.log(`Executing flow: ${flow.id}`);

    // Remove old flow and add new flow
    var filteredFlows = this.flows.filter(function(f: Flow) { 
      return f.id != flow.id; 
    });
    this.flows = filteredFlows;
    this.flows.push(flow);

    // Create connections
    for (const connection of flow.connections) {
      this.logger.log(`Creating connection: ${connection.fromComponent}.${connection.fromEvent} -> ${connection.toComponent}.${connection.toEvent}`);
      await this.backplaneService.publish('flow_exchange', 'createConnection', { ...connection, flowId: flow.id });
    }

    // Construct components
    let instances = [];
    for (const component of flow.components) {
      this.logger.log(`Constructing component: ${component.componentId} (${component.componentRef}) for flow: ${flow.id}`);
      
      // initialize a new component instance
      let componentInstance: Component = initializeComponent(flow, component, this.backplaneService, this.server, this.templateCacheService);

      // register new instance with component registery
      this.componentRegistry.registerComponent(componentInstance);
      instances.push(componentInstance);
    }

    // Sync connections for component
    for (const instance of instances) {
      this.logger.log(`Sync connections for component: ${instance.componentId} (${instance.componentRef}) for flow: ${instance.flowId}`);
      instance.syncConnections(flow.connections, this.componentRegistry);
    }
    
    // Init component
    for (const component of flow.components) {
      this.logger.log(`Initializing component: ${component.componentId} (${component.componentRef}) for flow: ${flow.id}`);

      try {
        await this.backplaneService.publish('flow_exchange', 'componentEvent', {
          flowId: flow.id,
          componentId: component.componentId,
          componentRef: component.componentRef,
          eventId: 'init',
          data: component.init,
        });
      } catch (error) {
        this.logger.error(`Error initializing component ${component.componentId} for flow ${flow.id}:`, error);
      }
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/processors/event.processor.ts">
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ComponentRegistry } from '../services/component-registry.service';
import { BackplaneService } from '../services/backplane.service';

@Injectable()
export class EventProcessor implements OnModuleInit {
  private readonly logger = new Logger(EventProcessor.name);
  private connections: Map<string, Array<{ toFlow: string; toComponent: string; toEvent: string }>> = new Map();

  constructor(
    private componentRegistry: ComponentRegistry,
    private backplaneService: BackplaneService
  ) {}

  async onModuleInit() {
    await this.subscribeToEvents();
  }

  private async subscribeToEvents() {
    try {
      await this.backplaneService.subscribe(
        'flow_exchange',
        'componentEvent',
        'component_event_queue',
        this.handleComponentEvent.bind(this)
      );

      await this.backplaneService.subscribe(
        'flow_exchange',
        'createConnection',
        'create_connection_queue',
        this.createConnection.bind(this)
      );
    } catch (error) {
      this.logger.error(`Failed to subscribe to events: ${error.message}`, error.stack);
    }
  }

  async handleComponentEvent(msg: {flowId: string, componentId: string, eventId: string, data: any}): Promise<void> {
    const { flowId, componentId, eventId, data: eventData } = msg;
    this.logger.log(`[handleComponentEvent] [${flowId}.${componentId}.${eventId}] data: ${JSON.stringify(eventData)}`);
    
    const component = this.componentRegistry.getComponent(flowId, componentId);
    if (component) {
      this.logger.log(`Passing event to component: ${componentId}`);
      await component.handleEvent(eventId, eventData);

      // Check if there are connections for this event
      const connectionKey = `${flowId}.${componentId}.${eventId}`;
      const connections = this.connections.get(connectionKey) || [];
      for (const connection of connections) {
        const { toFlow, toComponent, toEvent } = connection;
        this.logger.log(`[forwardingComponentEvent] [${toFlow}.${toComponent}.${toEvent}]`);
        
        const targetComponent = this.componentRegistry.getComponent(toFlow, toComponent);
        if (targetComponent) {
          this.logger.log(`Forwarding event to component: ${targetComponent.componentId}`);
          await targetComponent.handleEvent(toEvent, eventData);
        } else {
          this.logger.warn(`Target component not found: ${toComponent} in flow: ${toFlow}`);
        }
      }
    } else {
      this.logger.warn(`Component not found: ${flowId}.${componentId}`);
    }
  }

  async createConnection(msg: {flowId: string, fromComponent: string, fromEvent: string, toComponent: string, toEvent: string}): Promise<void>  {
    const { flowId, fromComponent, fromEvent, toComponent, toEvent } = msg;
    this.logger.log(`Received createConnection: ${flowId}.${fromComponent}.${fromEvent} -> ${toComponent}.${toEvent}`);
    
    const connectionKey = `${flowId}.${fromComponent}.${fromEvent}`;
    if (!this.connections.has(connectionKey)) {
      this.connections.set(connectionKey, []);
    }
    this.connections.get(connectionKey).push({ toFlow: flowId, toComponent, toEvent });
    this.logger.log(`Connection created: ${connectionKey} -> ${toComponent}.${toEvent}`);
  }
}
</FILE>
<FILE path="src/flows/benchmark.flow.ts" TARGET>
import { schema } from "../schema/flow.schema";
import { default as initJobStateMachine } from "src/stateMachines/job.state-machine";

let messageGenerator = {
  ports: {
    inputs: {
      start: {},
      stop: {}
    },
    outputs: {
      messageGenerated: {}
    }
  }
}

let messageProcessor = {
  ports: {
    inputs: {
      messageReceived: {}
    },
    outputs: {
      processingComplete: {}
    }
  }
}

let benchmarkAnalyzer = {
  ports: {
    inputs: {
      startBenchmark: {},
      endBenchmark: {},
      dataPoint: {}
    },
    outputs: {
      benchmarkResult: {}
    }
  }
}

let components = {
  gen: {
    messageGenerator
  },
  proc: {
    messageProcessor
  },
  analyzer: {
    benchmarkAnalyzer
  },
  sm: {
    stateMachine: {
      init: initJobStateMachine,
      ports: {
        inputs: {
          initStateMachine: {}
        },
        outputs: {}
      }
    }
  },
  jsm: {
    jobStateMachine: {
      ports: {
        inputs: {
          initProxyMachine: {},
          'set-start': {},
          'set-stop': {},
        },
        outputs: {
          'get-start': {},
          'get-stop': {},
          stateChanged: {}
        }
      }
    }
  }
}

let flow = {
  id: 'benchmark-flow',
  components,
  connections: [
    {
      from: 'components.sm.stateMachine.ports.outputs.initProxyMachine',
      to: 'components.jsm.jobStateMachine.ports.inputs.initProxyMachine'
    },
    {
      from: 'components.jsm.jobStateMachine.ports.outputs.get-start',
      to: 'components.gen.messageGenerator.ports.inputs.start'
    },
    {
      from: 'components.jsm.jobStateMachine.ports.outputs.get-stop',
      to: 'components.gen.messageGenerator.ports.inputs.stop'
    },
    {
      from: 'components.gen.messageGenerator.ports.outputs.messageGenerated',
      to: 'components.proc.messageProcessor.ports.inputs.messageReceived'
    },
    {
      from: 'components.proc.messageProcessor.ports.outputs.processingComplete',
      to: 'components.analyzer.benchmarkAnalyzer.ports.inputs.dataPoint'
    },
    {
      from: 'components.jsm.jobStateMachine.ports.outputs.get-start',
      to: 'components.analyzer.benchmarkAnalyzer.ports.inputs.startBenchmark'
    },
    {
      from: 'components.jsm.jobStateMachine.ports.outputs.get-stop',
      to: 'components.analyzer.benchmarkAnalyzer.ports.inputs.endBenchmark'
    }
  ]
};

export default schema(flow);
</FILE>
<REQUEST>
benchmark should stress test the system and be timed. test 1 byte messages to 10 bytes, 100, 1000, and 10000.
</REQUEST>