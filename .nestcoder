# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/flow-based-programming/src/logger/custom-logger.ts">
import { ConsoleLogger, Injectable, Inject } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class CustomLogger extends ConsoleLogger {
  constructor(
    private logId: string,
  ) {
    super(logId);
    this.setLogLevels(['log', 'error', 'warn', 'debug', 'verbose']);
  }

  log(message: string, context?: string) {
    this.printMessage(message, 'log', context);
    // this.emitLogEvent('log', message);
  }

  warn(message: string, context?: string) {
    this.printMessage(message, 'warn', context);
    // this.emitLogEvent('warn', message);
  }

  error(message: string, trace?: string, context?: string) {
    this.printMessage(message, 'error', context);
    // this.emitLogEvent('error', message);
    if (trace) {
      this.printMessage(trace, 'error', context);
    }
  }

  debug(message: string, context?: string) {
    this.printMessage(message, 'debug', context);
  }

  verbose(message: string, context?: string) {
    this.printMessage(message, 'verbose', context);
  }

  private printMessage(message: string, logLevel: string, context?: string) {
    const output = context ? `[${context}] ${message}` : message;
    console.log(`[${this.getNow()}] [${logLevel.toUpperCase()}] [${this.logId}] ${output}`);
  }

  private getNow(): string {
    return new Date().toISOString();
  }

  static write_to_file(message: string) {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    fs.appendFile(logFile, message, (err) => {
      if (err) {
        console.error('Failed to write to log file:', err);
      }
    });
  }

  static clearSTDOUT() {
    const logFile = path.join(process.cwd(), 'start:dev.stdout.txt');
    try {
      fs.writeFileSync(logFile, '');
      console.log(`Log file cleared at ${logFile}`);
    } catch (error) {
      console.error('Failed to clear log file:', error);
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/bases/component.base.ts">
import { Inject, Injectable } from '@nestjs/common';
import { Component } from '../interfaces/component.interface';
import { CustomLogger } from '../logger/custom-logger';
import { WebSocketGateway, WebSocketServer, SubscribeMessage, MessageBody } from '@nestjs/websockets';
import { Server } from 'socket.io';
import * as ejs from 'ejs';
import * as path from 'path';
import { Connection } from 'src/interfaces/connection.interface';
import { Port } from 'src/interfaces/port.interface';
import { ComponentRegistry } from 'src/services/component-registry.service';
import { TemplateCacheService } from 'src/services/template-cache.service';
import { BackplaneService } from '../services/backplane.service';

@WebSocketGateway()
@Injectable()
export abstract class ComponentBase implements Component {
  protected readonly logger: CustomLogger;
  public _ports: { inputs: Port[]; outputs: Port[]; };
  public ports: { inputs: string[]; outputs: string[]; };
  public _connections: Map<string, Component> = new Map();
  public connections: Connection[];
  
  constructor(
    public componentId: string,
    public slug: string,
    public description: string,
    public flowId: string,
    public componentRef: string,
    @Inject(BackplaneService) protected backplaneService: BackplaneService,
    protected server: Server,
    public templateCacheService: TemplateCacheService
  ) {
    this.logger = new CustomLogger(this.componentId);
  }

  abstract handleEvent(eventId: string, data: any): Promise<void>;

  async publish(flowId: string, componentId: string, eventId: string, data: any): Promise<void> {
    // this.logger.log(`Publishing: ${flowId}.${componentId}.${eventId} -> ${data}`); // keep important for debugging
    await this.backplaneService.publish('flow_exchange', 'componentEvent', {
      flowId,
      componentId,
      eventId,
      data,
    });
  }

  @SubscribeMessage('client-event')
  handleClientEvent(@MessageBody() data: any): void {
    const { flowId, componentId, eventId, ...eventData } = data;
    this.logger.log(`Received client event: flowId=${flowId}, componentId=${componentId}, eventId=${eventId}, data=${JSON.stringify(eventData)}`);
    this.publish(flowId, componentId, 'clientEventReceived', eventData);
  }

  public async display(flowId: string, componentId: string, templateId: string, data: any) {
    data._flowId = flowId;
    data._componentId = componentId;
    data._templateId = templateId;
    const htmxContent = await this.generateHtmxContent(data);
    
    // Cache the generated content
    const cacheKey = `${flowId}.${componentId}.${templateId}`;
    this.templateCacheService.setTemplate(cacheKey, htmxContent);

    if (this.server) {
      // this.logger.log(htmxContent);
      this.server.emit('display-flow-component-template-content', {
        flowId,
        componentId,
        templateId,
        content: htmxContent
      });
    } else {
      this.logger.warn('WebSocket server is not initialized');
    }
  }

  private async generateHtmxContent(data: any): Promise<string> {
    const templatePath = path.resolve(__dirname, `../templates/${data._templateId}.ejs`);
    try {
      return await ejs.renderFile(templatePath, data);
    } catch (error) {
      this.logger.error(`Error rendering EJS template: ${error.message}`);
      return `<div>Error rendering content</div>`;
    }
  }

  public syncConnections(connections: Connection[], componentRegistry: ComponentRegistry): void {
    if (connections) {
      this.connections = [];
      connections.forEach((connection, index) => {
        // console.log('connection', connection);
        // console.log('this.componentRegistry', componentRegistry)
        if (connection.fromFlow === this.flowId && connection.fromComponent === this.componentId) {
          // console.log(`from is the current instance so register to instance`);
          const connectionKey = `${connection.fromEvent}>${connection.toFlow}.${connection.toComponent}.${connection.toEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.toFlow, connection.toComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = connectedComponentInstance;
          connection.connectedFrom = this;
          this.connections.push(connection);
        } else if (connection.toFlow === this.flowId && connection.toComponent === this.componentId) {
          // console.log(`to is the current instance so register from instance`);
          const connectionKey = `${connection.toEvent}>${connection.fromFlow}.${connection.fromComponent}.${connection.fromEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.fromFlow, connection.fromComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = this;
          connection.connectedFrom = connectedComponentInstance;
          this.connections.push(connection);
        } else {
          // connection does not match; do nothing.
        }
      })
    }
  }

  // TODO: addPort()

  // TODO: removePort()

  // TODO: connectComponentToPort()

  // TODO: disconnectComponentFromPort()

  public async getPorts(): Promise<{ inputs: Port[], outputs: Port[] }> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    let ports = {
      inputs: [],
      outputs: []
    }
    this.ports.inputs.forEach(async (input) => {
      let i = input.split('.');
      let port: Port = {
        direction: 'input',
        dataType: i[0],
        dataMethod: i[1] === 'display' ? 'display' : 'publish',
        eventId: i[2],
        connections: [...await this.loadConnections('input', i[2])]
      }
      ports.inputs.push(port);
    });
    this.ports.outputs.forEach(async (output) => {
      let o = output.split('.');
      let port: Port = {
        direction: 'output',
        dataType: o[0],
        dataMethod: o[1] === 'display' ? 'display' : 'publish',
        eventId: o[2],
        connections: [...await this.loadConnections('output', o[2])]
      }
      ports.outputs.push(port);
    });
    this._ports = ports;
    return ports;
  }

  private async loadConnections(direction: string, eventId: string): Promise<Connection[]> {
    let connections: Connection[] = [];
    // console.log('this.connections', this.connections);
    if (this.connections) {
      this.connections.forEach((connection: Connection) => {
        // console.log('connection', connection);
        if (direction === 'input') {
          if (connection.toEvent === eventId) {
            connections.push(connection);
          }
        } else {
          if (connection.fromEvent === eventId) {
            connections.push(connection);
          }
        }
      });
      return connections;
    } else {
      return [];
    }
  }

  public async findPort(portId: string): Promise<Port> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    const pId = portId.split('.');
    const eventId = pId[2];
    const ports = await this.getPorts();
    let port: Port;
    ports.inputs.forEach((input: Port) => {
      if (input.eventId === eventId) {
        port = input;
      }
    });
    ports.outputs.forEach((output: Port) => {
      if (output.eventId === eventId) {
        port = output;
      }
    });
    return port;
  }

  public async findConnections(port: Port): Promise<Connection[]> {
    if (port && port.connections) {
      return port.connections;
    }
    return [];
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/services/backplane.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';

import { MessageQueueAdapter } from 'src/interfaces/message-queue-adapter.interface';
import { AmqpAdapter } from './backplanes/amqp.backplane';
import { IsmqAdapter } from './backplanes/ismq.backplane';

interface Subscription {
  exchange: string;
  routingKey: string;
  queue: string;
  callback: (msg: any) => Promise<void>;
}

@Injectable()
export class BackplaneService implements OnModuleInit, OnModuleDestroy {
  private adapter: MessageQueueAdapter;
  private readonly logger = new Logger(BackplaneService.name);
  private isConnecting = false;
  private isConnected = false;
  private reconnectInterval: NodeJS.Timeout | null = null;
  private subscriptions: Subscription[] = [];

  constructor() {
    const adapterType = process.env.MESSAGE_QUEUE_ADAPTER || 'ismq';
    this.adapter = adapterType === 'amqp' ? new AmqpAdapter(this.logger) : new IsmqAdapter(this.logger);
  }

  async onModuleInit() {
    await this.connect();
  }

  async onModuleDestroy() {
    await this.disconnect();
  }

  private async connect() {
    if (this.isConnecting || this.isConnected) {
      return;
    }

    this.isConnecting = true;
    try {
      await this.adapter.connect();
      this.isConnected = true;
      this.clearReconnectInterval();
      this.logger.log('Successfully connected to message queue');
      await this.resubscribeAll();
    } catch (error) {
      this.handleConnectionError(error);
    } finally {
      this.isConnecting = false;
    }
  }

  private async disconnect() {
    if (!this.isConnected) {
      return;
    }

    try {
      await this.adapter.disconnect();
      this.isConnected = false;
      this.clearReconnectInterval();
    } catch (error) {
      this.logger.error('Error disconnecting from message queue', error);
    }
  }

  async publish(exchange: string, routingKey: string, message: any): Promise<void> {
    await this.ensureConnection();
    try {
      await this.adapter.publish(exchange, routingKey, message);
    } catch (error) {
      this.handlePublishError(error);
    }
  }

  async subscribe(
    exchange: string,
    routingKey: string,
    queue: string,
    callback: (msg: any) => Promise<void>
  ): Promise<void> {
    await this.ensureConnection();
    try {
      await this.adapter.subscribe(exchange, routingKey, queue, callback);
      this.subscriptions.push({ exchange, routingKey, queue, callback });
    } catch (error) {
      this.handleSubscribeError(error);
    }
  }

  private async ensureConnection(): Promise<void> {
    if (!this.isConnected) {
      await this.connect();
    }
  }

  private startReconnectInterval(): void {
    if (!this.reconnectInterval) {
      this.logger.log('Starting backplane reconnection interval...');
      this.reconnectInterval = setInterval(() => {
        this.logger.log('Attempting to reconnect to backplane...');
        this.connect();
      }, 5000);
    }
  }

  private clearReconnectInterval(): void {
    if (this.reconnectInterval) {
      clearInterval(this.reconnectInterval);
      this.reconnectInterval = null;
      this.logger.log('Cleared reconnection interval');
    }
  }

  public async reset(): Promise<void> {
    this.logger.log('Resetting backplane connection...');
    await this.disconnect();
    await this.connect();
  }

  private async resubscribeAll(): Promise<void> {
    this.logger.log('Resubscribing to all previous subscriptions...');
    for (const sub of this.subscriptions) {
      try {
        await this.adapter.subscribe(sub.exchange, sub.routingKey, sub.queue, sub.callback);
        this.logger.log(`Resubscribed to ${sub.exchange} ${sub.routingKey} ${sub.queue}`);
      } catch (error) {
        this.logger.error(`Failed to resubscribe to ${sub.exchange} ${sub.routingKey} ${sub.queue}`, error);
      }
    }
  }

  private handleConnectionError(error: any) {
    this.isConnected = false;
    if (error.code === 'ECONNREFUSED') {
      // this.logger.error(`Failed to connect to message queue: ${error.message}`);
      this.startReconnectInterval();
    } else {
      this.logger.error('Unexpected error while connecting to message queue', error);
    }
  }

  private handlePublishError(error: any) {
    if (error.code === 'ECONNREFUSED') {
      // this.logger.error(`Failed to publish message: ${error.message}`);
      this.isConnected = false;
      this.startReconnectInterval();
    } else {
      this.logger.error('Unexpected error while publishing message', error);
    }
  }

  private handleSubscribeError(error: any) {
    if (error.code === 'ECONNREFUSED') {
      // this.logger.error(`Failed to subscribe: ${error.message}`);
      this.isConnected = false;
      this.startReconnectInterval();
    } else {
      this.logger.error('Unexpected error while subscribing', error);
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/services/template-cache.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class TemplateCacheService {
  private cache: Map<string, string> = new Map();

  setTemplate(key: string, content: string): void {
    this.cache.set(key, content);
  }

  getTemplate(key: string): string | undefined {
    return this.cache.get(key);
  }

  hasTemplate(key: string): boolean {
    return this.cache.has(key);
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/templates/benchmark-results.ejs">
<div id="benchmark-results">
  <h2>Benchmark Results</h2>
  <table>
    <thead>
      <tr>
        <th>Message Size</th>
        <th>Message Count</th>
        <th>Average Processing Time</th>
        <th>Messages per Second</th>
      </tr>
    </thead>
    <tbody>
      <% for (const [size, data] of Object.entries(results)) { %>
        <tr>
          <td><%= size %> bytes</td>
          <td><%= data.messageCount %></td>
          <td><%= data.averageProcessingTime.toFixed(2) %> ms</td>
          <td><%= data.messagesPerSecond %></td>
        </tr>
      <% } %>
    </tbody>
  </table>
</div>
</FILE>


<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/component.interface.ts">
import { Connection } from "./connection.interface";
import { Port } from "./port.interface";

export interface Component {
  ports: { inputs: string[]; outputs: string[]; };
  componentRef: string;
  slug: string;
  description?: string;
  flowId: string;
  componentId: string;
  handleEvent: (eventId: string, data: any) => Promise<void>;
  publish: (flowId: string, componentId: string, eventId: string, data: any) => Promise<void>;
  getPorts: () => Promise<{ inputs: Port[], outputs: Port[] }>;
  findPort: (portId: string) => Promise<Port>;
  findConnections: (port: Port) => Promise<Connection[]>
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/port.interface.ts">
import { Connection } from "./connection.interface";

// portId format: <dataType>.<dataMethod>.<eventId>
export interface Port {
  direction: 'input' | 'output'
  dataType: string;
  dataMethod: 'display' | 'publish';
  eventId: string;
  connections: Connection[];
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/flows/benchmark.flow.ts">
import { schema } from "../schema/flow.schema";
import { default as initJobStateMachine } from "src/stateMachines/job.state-machine";

let messageGenerator = {
  ports: {
    inputs: {
      start: {},
      stop: {},
      setMessageSize: {}
    },
    outputs: {
      messageGenerated: {}
    }
  }
}

let messageProcessor = {
  ports: {
    inputs: {
      messageReceived: {}
    },
    outputs: {
      processingComplete: {}
    }
  }
}

let benchmarkAnalyzer = {
  ports: {
    inputs: {
      startBenchmark: {},
      endBenchmark: {},
      dataPoint: {}
    },
    outputs: {
      benchmarkResult: {},
      startMessageGeneration: {},
      stopMessageGeneration: {},
      nextMessageSize: {}
    }
  },
  init: {
    messageSizes: [1, 10, 100, 1000, 10000],
    messagesPerSize: 500
  }
}

let buttonTrigger = {
  ports: {
    inputs: {
      triggerButton: {}
    },
    outputs: {
      buttonPressed: {}
    }
  }
}

let components = {
  gen: {
    messageGenerator
  },
  proc: {
    messageProcessor
  },
  analyzer: {
    benchmarkAnalyzer
  },
  sm: {
    stateMachine: {
      init: initJobStateMachine,
      ports: {
        inputs: {
          initStateMachine: {}
        },
        outputs: {}
      }
    }
  },
  jsm: {
    jobStateMachine: {
      ports: {
        inputs: {
          initProxyMachine: {},
          'set-start': {},
          'set-pause': {},
          'set-resume': {},
          'set-finish': {},
          'set-reset': {}
        },
        outputs: {
          'get-start': {},
          'get-pause': {},
          'get-resume': {},
          'get-finish': {},
          'get-reset': {},
          stateChanged: {}
        }
      }
    }
  },
  startBtn: { buttonTrigger },
  stopBtn: { buttonTrigger },
}

let flow = {
  id: 'benchmark-flow',
  components,
  connections: [
    {
      from: 'components.sm.stateMachine.ports.outputs.initProxyMachine',
      to: 'components.jsm.jobStateMachine.ports.inputs.initProxyMachine'
    },
    {
      from: 'components.jsm.jobStateMachine.ports.outputs.get-start',
      to: 'components.analyzer.benchmarkAnalyzer.ports.inputs.startBenchmark'
    },
    {
      from: 'components.analyzer.benchmarkAnalyzer.ports.outputs.nextMessageSize',
      to: 'components.gen.messageGenerator.ports.inputs.setMessageSize'
    },
    {
      from: 'components.jsm.jobStateMachine.ports.outputs.get-resume',
      to: 'components.analyzer.benchmarkAnalyzer.ports.inputs.startBenchmark'
    },
    {
      from: 'components.jsm.jobStateMachine.ports.outputs.get-finish',
      to: 'components.analyzer.benchmarkAnalyzer.ports.inputs.endBenchmark'
    },
    {
      from: 'components.jsm.jobStateMachine.ports.outputs.get-reset',
      to: 'components.analyzer.benchmarkAnalyzer.ports.inputs.startBenchmark'
    },
    {
      from: 'components.gen.messageGenerator.ports.outputs.messageGenerated',
      to: 'components.proc.messageProcessor.ports.inputs.messageReceived'
    },
    {
      from: 'components.proc.messageProcessor.ports.outputs.processingComplete',
      to: 'components.analyzer.benchmarkAnalyzer.ports.inputs.dataPoint'
    },
    {
      from: 'components.analyzer.benchmarkAnalyzer.ports.outputs.startMessageGeneration',
      to: 'components.gen.messageGenerator.ports.inputs.start'
    },
    {
      from: 'components.analyzer.benchmarkAnalyzer.ports.outputs.stopMessageGeneration',
      to: 'components.gen.messageGenerator.ports.inputs.stop'
    },
    {
      from: 'components.startBtn.buttonTrigger.ports.outputs.buttonPressed',
      to: 'components.jsm.jobStateMachine.ports.inputs.set-start'
    },
    {
      from: 'components.stopBtn.buttonTrigger.ports.outputs.buttonPressed',
      to: 'components.jsm.jobStateMachine.ports.inputs.set-finish'
    }
  ]
};

export default schema(flow);
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/message-generator/message-generator.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

@Injectable()
export class MessageGeneratorComponent extends ComponentBase {
  public logger: CustomLogger;
  private messageSize: number = 1;
  private messagesToGenerate: number = 500;
  private isGenerating: boolean = false;
  public ports = {
    inputs: [
      'any.publish.start',
      'any.publish.stop',
      'any.publish.setMessageSize'
    ],
    outputs: [
      'any.publish.messageGenerated'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('messageGenerator', 'message-generator', 'Generates messages for benchmarking', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    // this.logger.log(`MessageGenerator (${this.flowId}) handling event: ${eventId}`);
    switch (eventId) {
      case "init": {
        await this.initGenerator(data);
        break;
      }
      case "start": {
        await this.startGenerating();
        break;
      }
      case "stop": {
        this.stopGenerating();
        break;
      }
      case "setMessageSize": {
        this.setMessageSize(data.size);
        break;
      }
    }
  }

  private async initGenerator(data: any): Promise<void> {
    if (data && data.messagesPerSize) {
      this.messagesToGenerate = data.messagesPerSize;
    }
    this.logger.log(`MessageGenerator initialized with messages to generate: ${this.messagesToGenerate}`);
  }

  private async startGenerating(): Promise<void> {
    this.logger.log(`MessageGenerator (${this.flowId}) starting message generation`);
    this.isGenerating = true;
    
    for (let i = 0; i < this.messagesToGenerate + 10 && this.isGenerating; i++) {
      const message = { 
        timestamp: Date.now(), 
        content: "B".repeat(this.messageSize),
        size: this.messageSize
      };
      await this.publish(this.flowId, this.componentId, 'messageGenerated', message);
      
      // Optional: Add a small delay to prevent blocking the event loop
      if (i % 1000 === 0) {
        await new Promise(resolve => setImmediate(resolve));
      }
    }

    this.isGenerating = false;
    this.logger.log(`MessageGenerator (${this.flowId}) finished generating ${this.messagesToGenerate} messages`);
  }

  private stopGenerating(): void {
    this.logger.log(`MessageGenerator (${this.flowId}) stopping message generation`);
    this.isGenerating = false;
  }

  private setMessageSize(size: number): void {
    this.logger.log(`MessageGenerator (${this.flowId}) setting message size to ${size} bytes`);
    this.messageSize = size;
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/components/message-processor/message-processor.handler.ts">
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

@Injectable()
export class MessageProcessorComponent extends ComponentBase {
  public logger;
  public ports = {
    inputs: [
      'any.publish.messageReceived'
    ],
    outputs: [
      'any.publish.processingComplete'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('messageProcessor', 'message-processor', 'Processes messages for benchmarking', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    // this.logger.log(`MessageProcessor (${this.flowId}) handling event: ${eventId}`);
    switch (eventId) {
      case "messageReceived": {
        await this.processMessage(data);
        break;
      }
    }
  }

  private async processMessage(message: any): Promise<void> {
    const processingTime = Date.now() - message.timestamp;
    const size = message.size;
    await this.publish(this.flowId, this.componentId, 'processingComplete', { processingTime, size });
  }
}
</FILE>
<FILE path="src/components/benchmark-analyzer/benchmark-analyzer.handler.ts" TARGET>
import { CustomLogger } from '../../logger/custom-logger';
import { Injectable, Inject } from '@nestjs/common';
import { ComponentBase } from '../../bases/component.base';
import { BackplaneService } from 'src/services/backplane.service';
import { Server } from 'socket.io';
import { TemplateCacheService } from 'src/services/template-cache.service';

@Injectable()
export class BenchmarkAnalyzerComponent extends ComponentBase {
  public logger: CustomLogger;
  private startTime: number | null = null;
  private endTime: number | null = null;
  private dataPoints: { [size: number]: number[] } = {};
  private currentMessageSize: number = 1;
  private messageSizes: number[] = [1, 10, 100, 1000, 10000];
  private messagesPerSize: number = 500;
  private currentSizeIndex: number = 0;
  public ports = {
    inputs: [
      'any.publish.startBenchmark',
      'any.publish.endBenchmark',
      'any.publish.dataPoint'
    ],
    outputs: [
      'any.publish.benchmarkResult',
      'htmx.display.benchmark-results',
      'any.publish.startMessageGeneration',
      'any.publish.stopMessageGeneration',
      'any.publish.nextMessageSize'
    ]
  }

  constructor(
    @Inject('FLOW_ID') flowId: string,
    @Inject('COMPONENT_ID') componentId: string,
    @Inject(BackplaneService) backplane: BackplaneService,
    @Inject('WEB_SOCKET_SERVER') protected server: Server,
    @Inject('TEMPLATES') templates: TemplateCacheService
  ) {
    super('benchmarkAnalyzer', 'benchmark-analyzer', 'Analyzes benchmark results', flowId, componentId, backplane, server, templates);
    this.flowId = flowId;
    this.componentId = componentId;
    this.logger = new CustomLogger(`${flowId}.${componentId}`);
  }

  async handleEvent(eventId: string, data: any): Promise<void> {
    // this.logger.log(`BenchmarkAnalyzer (${this.flowId}) handling event: ${eventId}`);
    switch (eventId) {
      case "init": {
        await this.initBenchmark(data);
        break;
      }
      case "startBenchmark": {
        await this.startBenchmark();
        break;
      }
      case "endBenchmark": {
        await this.endBenchmark();
        break;
      }
      case "dataPoint": {
        await this.addDataPoint(data.processingTime, data.size);
        break;
      }
    }
  }

  private async initBenchmark(data: any): Promise<void> {
    if (data && data.messageSizes) {
      this.messageSizes = data.messageSizes;
    }
    if (data && data.messagesPerSize) {
      this.messagesPerSize = data.messagesPerSize;
    }
    this.logger.log(`Benchmark initialized with message sizes: ${this.messageSizes}, messages per size: ${this.messagesPerSize}`);
    this.resetDataPoints();
  }
  
  private async startBenchmark(): Promise<void> {
    this.startTime = Date.now();
    this.currentSizeIndex = 0;
    this.currentMessageSize = this.messageSizes[this.currentSizeIndex];
    this.resetDataPoints();
    
    console.log('========');
    console.log(`Benchmark started for size ${this.currentMessageSize} at ${this.startTime}`);
    console.log('========');
    await this.publish(this.flowId, this.componentId, 'startMessageGeneration', {});
  }

  private async endBenchmark(): Promise<void> {
    this.endTime = Date.now();
    this.logger.log(`Benchmark ended for size ${this.currentMessageSize} at ${this.endTime}`);

    await this.publish(this.flowId, this.componentId, 'stopMessageGeneration', {});

    console.log('========');
    console.log('waiting 2s for benchmark to finish');
    console.log('========');
    await new Promise(resolve => setTimeout(resolve, 2000)); // wait for benchmark to finish

    if (this.currentSizeIndex < this.messageSizes.length - 1) {
      this.currentSizeIndex++;
      await this.startNextSizeBenchmark();
    } else {
      const result = this.analyzeBenchmark();
      await this.publish(this.flowId, this.componentId, 'benchmarkResult', result);
      await this.display(this.flowId, this.componentId, 'benchmark-results', { results: result });
      console.log('!!!!!!!!');
      console.log('benchmark-results: success');
      console.log('!!!!!!!!');
    }
  }

  private async addDataPoint(processingTime: number, size: number): Promise<void> {
    // console.log('addDataPoint', size, processingTime);
    if (!this.dataPoints[size]) {
      this.dataPoints[size] = [];
    }
    this.dataPoints[size].push(processingTime);
    // this.logger.log(`Added data point for size ${size}: ${processingTime}ms (Total: ${this.dataPoints[size].length})`);
    
    if (this.dataPoints[size].length === this.messagesPerSize) {
      console.log('////////// end benchmark', this.dataPoints[size].length, '===', this.messagesPerSize);
      await this.endBenchmark();
    }
  }

  private async startNextSizeBenchmark(): Promise<void> {
    this.currentMessageSize = this.messageSizes[this.currentSizeIndex];
    this.logger.log(`Starting benchmark for next size: ${this.currentMessageSize}`);
    await this.publish(this.flowId, this.componentId, 'nextMessageSize', { size: this.currentMessageSize });
    console.log('~~~~~~ startNextSizeBenchmark', this.currentMessageSize);
    await new Promise(resolve => setTimeout(resolve, 2000)); // wait for nextMessageSize to propagate
    await this.publish(this.flowId, this.componentId, 'startMessageGeneration', {});
    await this.publish(this.flowId, this.componentId, 'startMessageGeneration', {});
    await this.publish(this.flowId, this.componentId, 'startMessageGeneration', {});
  }

  private analyzeBenchmark(): BenchmarkResults {
    const results: BenchmarkResults = {};

    for (const size of this.messageSizes) {
      const times = this.dataPoints[size] || [];
      const messageCount = times.length;
      const totalTime = times.reduce((sum, time) => sum + time, 0);
      const averageProcessingTime = messageCount > 0 ? totalTime / messageCount : 0;
      const messagesPerSecond = messageCount > 0 ? (messageCount / (totalTime / 1000)).toFixed(2) : '0';

      results[size] = {
        messageCount,
        averageProcessingTime,
        messagesPerSecond,
      };

      this.logger.log(`Analysis for size ${size}: Count=${messageCount}, Avg=${averageProcessingTime.toFixed(2)}ms, MPS=${messagesPerSecond}`);
    }

    return results;
  }

  private resetDataPoints(): void {
    this.dataPoints = {};
    this.messageSizes.forEach(size => {
      this.dataPoints[size] = [];
    });
    this.logger.log('Data points reset');
  }
}

interface BenchmarkResult {
  messageCount: number;
  averageProcessingTime: number;
  messagesPerSecond: string;
}

interface BenchmarkResults {
  [size: number]: BenchmarkResult;
}
</FILE>
<REQUEST>
within benchmark results messages per second should be calculated by the amount of time it took to get all the messages; do not use a formula just use a startAt and finishAt and get the difference.
</REQUEST>