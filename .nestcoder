# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/component-selector.ejs">
<div class="component-selector">
  <h3>Select a Component</h3>
  <ul>
    <% components.forEach(function(component) { %>
      <li>
        <a href="/document/<%= flowId %>/<%= component.componentId %>"
           hx-get="/document/<%= flowId %>/<%= component.componentId %>"
           hx-target="body"
           hx-push-url="true">
          <%= component.componentId %> (<%= component.componentRef %>)
        </a>
      </li>
    <% }); %>
  </ul>
</div>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/view.ejs">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%- message %></title>
  <script src="https://unpkg.com/htmx.org@2.0.2"></script>
  <script src="https://unpkg.com/htmx.org@1.9.12/dist/ext/json-enc.js"></script>
  <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script>
  <%- include('style') %>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <%- include('component-selector', { flowId: selected.flowId, components: components }) %>
    </div>
    <div class="main-content">
      <div id="swimlane-container" class="swimlane-container">
        <div id="main-swimlane" class="swimlane" data-index="0"
             hx-get="/documentComponent/<%= selected.flowId %>/<%= selected.componentId %>/main-swimlane"
             hx-trigger="load"
             hx-target="#main-swimlane">
          <!-- Main component will be loaded here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    const socket = io();

    socket.on('display-flow-component-template-content', function(event) {
      const targetId = `${event.flowId}.${event.componentId}.${event.templateId}`;
      const targetElement = document.getElementById(targetId);
      console.log(targetId, event.content);
      if (targetElement) {
        targetElement.outerHTML = event.content;
        // Reinitialize HTMX on the new content
        htmx.process(document.getElementById(targetId));
      }
    });

    htmx.on("htmx:configRequest", (event) => {
      event.detail.headers['Content-Type'] = 'application/json';
    });
  </script>
  <%- include('methods') %> 
</body>
</html>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/component.ejs">
<% if (component) { %>
  <div id="<%- component.flowId %>.<%- component.componentId %>">
    <div class="event-anchor input-anchors">
      <% component.ports.inputs.forEach((input, index) => { %>
        <% if (index !== 0) { %>
         <hr>
        <% } %>
        <button onclick="loadConnectedComponents('input', '<%- component.flowId %>', '<%- component.componentId %>', '<%- input %>', '<%- swimlaneId %>')">input</button>
        <div style="float: right;">
          <%- input %>
        </div>
        <br />
      <% }) %>
    </div>
    <div id="number-generator" class="component">
      <h2><%- component.componentId %> (<%- component.slug %>)</h2>
      <p><%- component.description %> </p>
      <button hx-post="/trigger-event/<%- component.flowId %>.<%- component.componentId %>.start"
        hx-swap="none" 
        hx-ext='json-enc'
        hx-headers='{"Content-Type": "application/json"}'
        hx-vals='{}'
      >
        Start Generating
      </button>
      <button hx-post="/trigger-event/<%- component.flowId %>.<%- component.componentId %>.stop"
        hx-swap="none" 
        hx-ext='json-enc'
        hx-headers='{"Content-Type": "application/json"}'
        hx-vals='{}'
      >
        Stop Generating
      </button>
    </div>
    <div class="event-anchor output-anchors">
      <% component.ports.outputs.forEach((output, index) => { %>
        <% if (index !== 0) { %>
         <hr>
        <% } %>
        <button onclick="loadConnectedComponents('output', '<%- component.flowId %>', '<%- component.componentId %>', '<%- output %>', '<%- swimlaneId %>')" style="float: right;">output</button>
        <%- output %> <br />
      <% }) %>
    </div>
  </div>
<% } else { %>
  <p>no component found</p>  
<% } %>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/style.ejs">
<style>
  /* ... (existing styles) ... */

  .container {
    display: flex;
    height: 100vh;
  }

  .sidebar {
    width: 250px;
    background-color: #f0f0f0;
    padding: 20px;
    overflow-y: auto;
  }

  .main-content {
    flex-grow: 1;
    overflow-y: auto;
  }

  .component-selector h3 {
    margin-top: 0;
  }

  .component-selector ul {
    list-style-type: none;
    padding: 0;
  }

  .component-selector li {
    margin-bottom: 10px;
  }

  .component-selector a {
    text-decoration: none;
    color: #333;
  }

  .component-selector a:hover {
    text-decoration: underline;
  }
</style>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/views/document/methods.ejs">
<script>
  function getNextSwimlane(direction, mainSwimlane) {
    const mainIndex = parseInt(mainSwimlane.getAttribute('data-index'));
    
    let targetIndex, targetSwimlane;
    if (direction === 'input') {
      targetIndex = mainIndex - 1;
      targetSwimlane = getOrCreateSwimlane(targetIndex);
    } else {
      targetIndex = mainIndex + 1;
      targetSwimlane = getOrCreateSwimlane(targetIndex);
    }

    return {
      mainIndex,
      targetIndex,
      targetSwimlane
    }
  }

  function loadConnectedComponents(direction, flowId, componentId, port, swimlaneId) {
    console.log('swimload load connected', swimlaneId, direction);
    const mainSwimlane = document.getElementById(swimlaneId);
    let next = getNextSwimlane(direction, mainSwimlane);

    const eventElement = document.createElement('div');
    eventElement.setAttribute("id", `${flowId}.${componentId}.${port}`);
    next.targetSwimlane.innerHTML = '';
    next.targetSwimlane.appendChild(eventElement);
    
    htmx.ajax('GET', `/documentConnections/${flowId}/${componentId}/${port}/${next.targetSwimlane.id}`, {
      swap: 'none',
      handler: (dom, event) => {
        document.getElementById(`${flowId}.${componentId}.${port}`).outerHTML = event.xhr.response;
      }
    });
  }

  function loadMainComponent(direction, flowId, componentId, swimlaneId) {
    console.log('swimload load main', swimlaneId, direction);
    // Update the main swimlane
    const mainSwimlane = document.getElementById(swimlaneId);
    let next = getNextSwimlane(direction, mainSwimlane);
    next.targetSwimlane.innerHTML = '';
    
    htmx.ajax('GET', `/documentComponent/${flowId}/${componentId}/${next.targetSwimlane.id}`, {
      swap: 'none',
      handler: (dom, event) => {
        next.targetSwimlane.innerHTML = event.xhr.response;
      }
    });
  }

  function getOrCreateSwimlane(index) {
    let swimlane = document.querySelector(`.swimlane[data-index="${index}"]`);
    if (swimlane) {
      console.log('swimlane found', index, swimlane)
    } else {
      console.log('swimlane not found', index)
    }
    if (!swimlane) {
      swimlane = document.createElement('div');
      swimlane.className = 'swimlane';
      swimlane.setAttribute('data-index', index);
      swimlane.id = `swimlane-${index}`;
      
      const container = document.getElementById('swimlane-container');
      if (index < 0) {
        container.insertBefore(swimlane, container.firstChild);
      } else {
        container.appendChild(swimlane);
      }
    }
    return swimlane;
  }
</script>
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/services/flow-executor.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { ComponentRegistry } from './component-registry.service';
import { Flow } from '../interfaces/flow.interface';
import { WebSocketGateway, WebSocketServer } from '@nestjs/websockets';
import { Server } from 'socket.io';
import { initializeComponent } from '../initializers/component.initialize';
import { Component } from 'src/interfaces/component.interface';

@WebSocketGateway()
@Injectable()
export class FlowExecutorService {
  @WebSocketServer() server: Server;
  private readonly logger = new Logger(FlowExecutorService.name);

  constructor(
    private amqpConnection: AmqpConnection,
    private componentRegistry: ComponentRegistry
  ) {}

  async executeFlow(flow: Flow) {
    this.logger.log(`Executing flow: ${flow.id}`);

    // Create connections
    for (const connection of flow.connections) {
      this.logger.log(`Creating connection: ${connection.fromComponent}.${connection.fromEvent} -> ${connection.toComponent}.${connection.toEvent}`);
      await this.amqpConnection.publish('flow_exchange', 'createConnection', { ...connection, flowId: flow.id });
    }

    // Construct components
    let instances = [];
    for (const component of flow.components) {
      this.logger.log(`Constructing component: ${component.componentId} (${component.componentRef}) for flow: ${flow.id}`);
      
      // initialize a new component instance
      let componentInstance: Component = initializeComponent(flow, component, this.amqpConnection, this.server);

      // register new instance with component registery
      this.componentRegistry.registerComponent(componentInstance);
      instances.push(componentInstance);
    }

    // Sync connections for component
    for (const instance of instances) {
      this.logger.log(`Sync connections for component: ${instance.componentId} (${instance.componentRef}) for flow: ${instance.flowId}`);
      instance.syncConnections(flow.connections, this.componentRegistry);
    }
    
    // Init component
    for (const component of flow.components) {
      this.logger.log(`Initializing component: ${component.componentId} (${component.componentRef}) for flow: ${flow.id}`);

      try {
        await this.amqpConnection.publish('flow_exchange', 'componentEvent', {
          flowId: flow.id,
          componentId: component.componentId, // dynamically defined
          componentRef: component.componentRef, // hard code defined
          eventId: 'init', // flow executor defined
          data: component.init, // dynamically defined
        });
      } catch (error) {
        this.logger.error(`Error initializing component ${component.componentId} for flow ${flow.id}:`, error);
      }
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/services/component-registry.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { Component } from '../interfaces/component.interface';

@Injectable()
export class ComponentRegistry {
  private components: Map<string, Component> = new Map();
  private readonly logger = new Logger(ComponentRegistry.name);

  registerComponent(component: Component) {
    const key = `${component.flowId}.${component.componentId}`;
    this.logger.log(`Registering component: ${key}`);
    this.components.set(key, component);
  }

  getComponent(flowId: string, componentId: string): Component | undefined {
    const key = `${flowId}.${componentId}`;
    const component = this.components.get(key);
    if (!component) {
      this.logger.warn(`Component not found: ${key}`);
    }
    return component;
  }
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/flow.interface.ts">
import { Connection } from "./connection.interface";

export interface Flow {
  id: string;
  components: {
    componentId: string;
    componentRef: string;
    init: any | undefined;
  }[];
  connections: Connection[];
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/interfaces/component.interface.ts">
import { Connection } from "./connection.interface";
import { Port } from "./port.interface";

export interface Component {
  ports: { inputs: string[]; outputs: string[]; };
  componentRef: string;
  slug: string;
  description?: string;
  flowId: string;
  componentId: string;
  handleEvent: (eventId: string, data: any) => Promise<void>;
  publish: (flowId: string, componentId: string, eventId: string, data: any) => Promise<void>;
  getPorts: () => Promise<{ inputs: Port[], outputs: Port[] }>;
  findPort: (portId: string) => Promise<Port>;
  findConnections: (port: Port) => Promise<Connection[]>
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/controllers/app.controller.ts">
import { Logger, Controller, Get, Post, Render, Body, Param, Res, Req } from '@nestjs/common';
import { Response, Request } from 'express';
import { EventTriggerComponent } from '../components/event-trigger/event-trigger.handler';

import { ComponentRegistry } from 'src/services/component-registry.service';
import { Connection } from 'src/interfaces/connection.interface';
import { Port } from 'src/interfaces/port.interface';
import { FlowExecutorService } from 'src/services/flow-executor.service';

@Controller()
export class AppController {
  private readonly logger = new Logger('AppController');
  
  constructor(
    private eventTriggerComponent: EventTriggerComponent,
    private componentRegistry: ComponentRegistry,
    private flowExecutorService: FlowExecutorService
  ) {}

  // ... (other methods remain the same)

  @Get('document')
  @Render('document/index')
  async documentIndex(
    @Req() req: Request
  ) {
    const flows = await this.flowExecutorService.getFlows();
    const firstFlow = flows[0]; // Assuming we're working with the first flow
    const components = firstFlow.components.map(c => ({
      componentId: c.componentId,
      componentRef: c.componentRef
    }));

    return {
      message: 'document - steam engine // FBP',
      flowId: firstFlow.id,
      components
    };
  }

  @Get('document/:flowId/:componentId')
  @Render('document/view')
  async documentView(
    @Param('flowId') flowId: string,
    @Param('componentId') componentId: string,
    @Req() req: Request
  ) {
    const flow = await this.flowExecutorService.getFlow(flowId);
    const components = flow.components.map(c => ({
      componentId: c.componentId,
      componentRef: c.componentRef
    }));

    return {
      selected: {
        flowId,
        componentId
      },
      components,
      message: `${flowId}.${componentId} - document - steam engine // FBP`
    };
  }

  // ... (other methods remain the same)
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/modules/app.module.ts">
import { RabbitMQModule } from '@golevelup/nestjs-rabbitmq';
import { ComponentRegistry } from '../services/component-registry.service';
import { FlowExecutorService } from '../services/flow-executor.service';
import { EventProcessor } from '../processors/event.processor';
import { CustomLogger } from '../logger/custom-logger';
import { AppController } from '../controllers/app.controller';

import { initializeAppModule, components } from '../initializers/app.initialize';

const metadata = {
  imports: [
    RabbitMQModule.forRoot(RabbitMQModule, {
      exchanges: [
        {
          name: 'flow_exchange',
          type: 'topic',
        },
      ],
      uri: 'amqp://localhost:5672',
      connectionInitOptions: { wait: false },
    }),
  ],
  controllers: [AppController],
  providers: [
    EventProcessor,
    ComponentRegistry,
    FlowExecutorService,
    {
      provide: 'FLOW_ID',
      useValue: 'example-flow', // Use a default flow ID
    },
    {
      provide: 'COMPONENT_ID',
      useFactory: () => `component-${Date.now()}`, // Generate a unique component ID
    },
    {
      provide: 'WEB_SOCKET_SERVER',
      useValue: null, // This will be set later in the FlowExecutorService
    },
    ...components,
    CustomLogger
  ],
  exports: [EventProcessor],
}

export const AppModule = initializeAppModule(metadata)
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/schema/flow.schema.ts">
import { Flow } from "../interfaces/flow.interface";

export function schema(flow: any): Flow {
  const components = Object.entries(flow.components).map(([componentId, component]) => {
    const [componentRef] = Object.keys(component);
    let init;
    let ports = { inputs: [], outputs: [] };

    if (component[componentRef].init) {
      init = component[componentRef].init;
    }

    if (component[componentRef].ports) {
      if (component[componentRef].ports.inputs) {
        ports.inputs = Object.keys(component[componentRef].ports.inputs);
      }
      if (component[componentRef].ports.outputs) {
        ports.outputs = Object.keys(component[componentRef].ports.outputs);
      }
    }

    return { componentId, componentRef, init, ports };
  });

  const connections = flow.connections.map((connection) => {
    const fromParts = connection.from.split('.');
    const toParts = connection.to.split('.');

    // parts format: components.<componentId>.<componentRef>.ports.inputs.<eventId>
    
    return {
      fromFlow: flow.id,
      fromComponent: fromParts[1],
      fromEvent: fromParts[5],
      toFlow: flow.id,
      toComponent: toParts[1],
      toEvent: toParts[5],
    };
  });

  let code = {
    id: flow.id,
    components,
    connections,
  };

  // console.log('code', code);

  return code;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/initializers/flows.initialize.ts">
import { FlowBase } from "src/bases/flow.base";

import {default as exampleFlow} from "src/flows/example-flow.flow";

const flows = [
  new FlowBase(exampleFlow.id, exampleFlow.components, exampleFlow.connections),
];

export async function initializeFlows(flowExecutor) {
  flows.forEach(async (flow) => {
    await flowExecutor.executeFlow(flow);
  })
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/initializers/component.initialize.ts">
import { EventTriggerComponent } from '../components/event-trigger/event-trigger.handler';
import { NumberGeneratorComponent } from '../components/number-generator/number-generator.handler';
import { NumberMultiplierComponent } from '../components/number-multiplier/number-multiplier.handler';
import { StateMachineComponent } from 'src/components/state-machine/state-machine.handler';
import { JobStateMachineComponent } from 'src/components/job-state-machine/job-state-machine.handler';
import { ButtonTriggerComponent } from 'src/components/button-trigger/button-trigger.handler';

export function initializeComponent(flow, component, amqpConnection, server) {
  let componentInstance;
  switch (component.componentRef) {
    case 'eventTrigger':
      componentInstance = new EventTriggerComponent(flow.id, component.componentId, amqpConnection, server);
      break;
    case 'numberGenerator':
      componentInstance = new NumberGeneratorComponent(flow.id, component.componentId, amqpConnection, server);
      break;
    case 'numberMultiplier':
      componentInstance = new NumberMultiplierComponent(flow.id, component.componentId, amqpConnection, server);
      break;
    case 'stateMachine':
      componentInstance = new StateMachineComponent(flow.id, component.componentId, amqpConnection, server);
      break;
    case 'jobStateMachine':
      componentInstance = new JobStateMachineComponent(flow.id, component.componentId, amqpConnection, server);
      break;
    case 'buttonTrigger':
      componentInstance = new ButtonTriggerComponent(flow.id, component.componentId, amqpConnection, server);
      break;
    default:
      this.logger.warn(`Unknown component type: ${component.componentRef}`);
      break;
  }
  return componentInstance;
}
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/bases/flow.base.ts">
import { Connection } from 'src/interfaces/connection.interface';
import { Flow } from '../interfaces/flow.interface';

export class FlowBase implements Flow {
  public connections: Connection[] = [];
  constructor(
    public id: string,
    public components: any,
    public _connections: {
      fromComponent: string;
      fromEvent: string;
      toComponent: string;
      toEvent: string;
    }[]
  ) {
    this.id = id;
    this.components = components;
    this._connections = _connections;
    this.setupConnections();
  }

  private async setupConnections(): Promise<Connection[]> {
    this._connections.forEach((connection) => {
      let c: Connection = {
        ...connection,
        toFlow: this.id,
        fromFlow: this.id,
        connectedTo: undefined, // TODO
        connectedFrom: undefined, // TODO
        next: undefined // TODO
      }
      this.connections.push(c);
    })
    return this.connections;
  }
};
</FILE>
<FILE path="/home/travis/Projects/flow-based-programming/src/bases/component.base.ts">
import { Inject, Injectable } from '@nestjs/common';
import { AmqpConnection } from '@golevelup/nestjs-rabbitmq';
import { Component } from '../interfaces/component.interface';
import { CustomLogger } from '../logger/custom-logger';
import { WebSocketGateway, WebSocketServer, SubscribeMessage, MessageBody } from '@nestjs/websockets';
import { Server } from 'socket.io';
import * as ejs from 'ejs';
import * as path from 'path';
import { Connection } from 'src/interfaces/connection.interface';
import { Port } from 'src/interfaces/port.interface';
import { ComponentRegistry } from 'src/services/component-registry.service';

@WebSocketGateway()
@Injectable()
export abstract class ComponentBase implements Component {
  protected readonly logger: CustomLogger;
  public _ports: { inputs: Port[]; outputs: Port[]; };
  public ports: { inputs: string[]; outputs: string[]; };
  public _connections: Map<string, Component> = new Map();
  public connections: Connection[];

  constructor(
    public componentId: string,
    public slug: string,
    public description: string,
    public flowId: string,
    public componentRef: string,
    @Inject(AmqpConnection) protected amqpConnection: AmqpConnection,
    protected server: Server,
  ) {
    this.logger = new CustomLogger(this.componentId, amqpConnection);
  }

  abstract handleEvent(eventId: string, data: any): Promise<void>;

  async publish(flowId: string, componentId: string, eventId: string, data: any): Promise<void> {
    this.logger.log(`Publishing: ${flowId}.${componentId}.${eventId} -> ${data}`);
    if (!this.amqpConnection) {
      this.logger.error('AmqpConnection is not initialized');
      return;
    }
    await this.amqpConnection.publish('flow_exchange', 'componentEvent', {
      flowId,
      componentId,
      eventId,
      data,
    });
  }

  @SubscribeMessage('client-event')
  handleClientEvent(@MessageBody() data: any): void {
    const { flowId, componentId, eventId, ...eventData } = data;
    this.logger.log(`Received client event: flowId=${flowId}, componentId=${componentId}, eventId=${eventId}, data=${JSON.stringify(eventData)}`);
    this.publish(flowId, componentId, 'clientEventReceived', eventData);
  }

  public async display(flowId: string, componentId: string, templateId: string, data: any) {
    data._flowId = flowId;
    data._componentId = componentId;
    data._templateId = templateId;
    const htmxContent = await this.generateHtmxContent(data);
    
    if (this.server) {
      // this.logger.log(htmxContent);
      this.server.emit('display-flow-component-template-content', {
        flowId,
        componentId,
        templateId,
        content: htmxContent
      });
    } else {
      this.logger.warn('WebSocket server is not initialized');
    }
  }

  private async generateHtmxContent(data: any): Promise<string> {
    const templatePath = path.resolve(__dirname, `../templates/${data._templateId}.ejs`);
    try {
      return await ejs.renderFile(templatePath, data);
    } catch (error) {
      this.logger.error(`Error rendering EJS template: ${error.message}`);
      return `<div>Error rendering content</div>`;
    }
  }

  public syncConnections(connections: Connection[], componentRegistry: ComponentRegistry): void {
    if (connections) {
      this.connections = [];
      connections.forEach((connection, index) => {
        // console.log('connection', connection);
        // console.log('this.componentRegistry', componentRegistry)
        if (connection.fromFlow === this.flowId && connection.fromComponent === this.componentId) {
          // console.log(`from is the current instance so register to instance`);
          const connectionKey = `${connection.fromEvent}>${connection.toFlow}.${connection.toComponent}.${connection.toEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.toFlow, connection.toComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = connectedComponentInstance;
          connection.connectedFrom = this;
          this.connections.push(connection);
        } else if (connection.toFlow === this.flowId && connection.toComponent === this.componentId) {
          // console.log(`to is the current instance so register from instance`);
          const connectionKey = `${connection.toEvent}>${connection.fromFlow}.${connection.fromComponent}.${connection.fromEvent}`;
          const connectedComponentInstance = componentRegistry.getComponent(connection.fromFlow, connection.fromComponent);
          this._connections.set(connectionKey, connectedComponentInstance);
          connection.connectedTo = this;
          connection.connectedFrom = connectedComponentInstance;
          this.connections.push(connection);
        } else {
          // connection does not match; do nothing.
        }
      })
    }
  }

  // TODO: addPort()

  // TODO: removePort()

  // TODO: connectComponentToPort()

  // TODO: disconnectComponentFromPort()

  public async getPorts(): Promise<{ inputs: Port[], outputs: Port[] }> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    let ports = {
      inputs: [],
      outputs: []
    }
    this.ports.inputs.forEach(async (input) => {
      let i = input.split('.');
      let port: Port = {
        direction: 'input',
        dataType: i[0],
        dataMethod: i[1] === 'display' ? 'display' : 'publish',
        eventId: i[2],
        connections: [...await this.loadConnections('input', i[2])]
      }
      ports.inputs.push(port);
    });
    this.ports.outputs.forEach(async (output) => {
      let o = output.split('.');
      let port: Port = {
        direction: 'output',
        dataType: o[0],
        dataMethod: o[1] === 'display' ? 'display' : 'publish',
        eventId: o[2],
        connections: [...await this.loadConnections('output', o[2])]
      }
      ports.outputs.push(port);
    });
    this._ports = ports;
    return ports;
  }

  private async loadConnections(direction: string, eventId: string): Promise<Connection[]> {
    let connections: Connection[] = [];
    // console.log('this.connections', this.connections);
    if (this.connections) {
      this.connections.forEach((connection: Connection) => {
        // console.log('connection', connection);
        if (direction === 'input') {
          if (connection.toEvent === eventId) {
            connections.push(connection);
          }
        } else {
          if (connection.fromEvent === eventId) {
            connections.push(connection);
          }
        }
      });
      return connections;
    } else {
      return [];
    }
  }

  public async findPort(portId: string): Promise<Port> {
    // portId format: <dataType>.<dataMethod>.<eventId>
    const pId = portId.split('.');
    const eventId = pId[2];
    const ports = await this.getPorts();
    let port: Port;
    ports.inputs.forEach((input: Port) => {
      if (input.eventId === eventId) {
        port = input;
      }
    });
    ports.outputs.forEach((output: Port) => {
      if (output.eventId === eventId) {
        port = output;
      }
    });
    return port;
  }

  public async findConnections(port: Port): Promise<Connection[]> {
    if (port && port.connections) {
      return port.connections;
    }
    return [];
  }
}
</FILE>
<FILE path="src/views/document/index.ejs" TARGET>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%- message %></title>
  <script src="https://unpkg.com/htmx.org@2.0.2"></script>
  <script src="https://unpkg.com/htmx.org@1.9.12/dist/ext/json-enc.js"></script>
  <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script>
  <%- include('style') %>
</head>
<body>
  <h1>Flow Components</h1>
  
  <%- include('component-selector', { flowId: flowId, components: components }) %>

  <div id="component-details">
    <p>Select a component to view its details.</p>
  </div>

  <script>
    const socket = io();

    socket.on('display-flow-component-template-content', function(event) {
      const targetId = `${event.flowId}.${event.componentId}.${event.templateId}`;
      const targetElement = document.getElementById(targetId);
      console.log(targetId, event.content);
      if (targetElement) {
        targetElement.outerHTML = event.content;
      }
    });

    htmx.on("htmx:configRequest", (event) => {
      event.detail.headers['Content-Type'] = 'application/json';
    });
  </script>
  <%- include('methods') %> 
</body>
</html>
</FILE>
<REQUEST>
there should be another template that loads here and within view.ejs that allows the user to select between all of the different components within the flow ... You'll need to implement the `getFlows()` and `getFlow(flowId)` methods in the `FlowExecutorService` to retrieve the necessary flow and component information.
</REQUEST>